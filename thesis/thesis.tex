%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% This option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
  twoside, %% This option enables double-sided typesetting. Use at
           %% least 120 g/m² paper to prevent show-through. Replace
           %% with `oneside` to use one-sided typesetting; use only
           %% if you don’t have access to a double-sided printer,
           %% or if one-sided typesetting is a formal requirement
           %% at your faculty.
  table,   %% This option causes the coloring of tables. Replace
           %% with `notable` to restore plain LaTeX tables.
  lof,     %% This option prints the List of Figures. Replace with
           %% `nolof` to hide the List of Figures.
  lot,     %% This option prints the List of Tables. Replace with
           %% `nolot` to hide the List of Tables.
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = bc,
    author        = {Tereza Šťastná},
    gender        = f,
    advisor       = {doc. RNDr. Jan Strejček, Ph.D.},
    title         = {Simplification\\ of Acceptance Condition\\ of Emerson-Lei Automata},
    TeXtitle      = {Simplification\\ of Acceptance Condition\\ of Emerson-Lei Automata},
    keywords      = {TELA, TGBA, omega-automata, SPOT, SCC-based simplifications, automata reduction},
    TeXkeywords   = {TELA, TGBA, $\omega$-automata, SPOT, SCC-based simplifications, automata reduction},
    abstract      = {%
    This thesis proposes SCC-based simplifications of acceptance condition formulae for transition-based Emerson-Lei automata (TELA). These simplifications aim to reduce the number of unique acceptance sets of the automaton and possibly reduce the length of the acceptance formula. The thesis includes an experimental implementation of the proposed method and experimental evaluation of the implemented tool. 
    },
    thanks        = {Many thanks to Jan Strejček for all his advice and patience during the thesis work. I would like to thank Juraj Major for his kind help and to my family and friends for their support.
    },
    bib           = bibliography.bib,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} 
\usepackage{amsmath}  
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{pgfplots}
\usepackage{url}      
\usepackage{markdown} 
\usepackage{tabularx} 
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} 
\usepackage{tikz}
\usetikzlibrary{automata,nicearrows,bending,myautomata}
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
%% The following code fixes the rendering of BibLaTeX ISO 690
%% references in old TeX Live (such as the one at Overleaf).
\thesisload
\makeatletter
\def\thesis@biblatexiso@fix@package{iso-numeric.bbx}
\def\thesis@biblatexiso@fix@end{\relax}
\newif\ifthesis@biblatexiso@fix@
\thesis@biblatexiso@fix@false
\def\thesis@biblatexiso@fix@next#1,{%
  \def\thesis@biblatexiso@fix@current{#1}%
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@package
    \thesis@biblatexiso@fix@true
  \fi
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@end
    \expandafter
    \@gobble
  \fi
  \thesis@biblatexiso@fix@next
}
\expandafter\expandafter\expandafter\thesis@biblatexiso@fix@next\@filelist,\relax,
\ifthesis@biblatexiso@fix@
  \defbibenvironment{bibliography}
    {\list%
       {\MethodFormat}%
       {\setlength{\labelwidth}{\labelnumberwidth}%
        \setlength{\leftmargin}{\labelwidth}%
        \setlength{\labelsep}{\biblabelsep}%
        \addtolength{\leftmargin}{\labelsep}%
        \setlength{\itemsep}{\bibitemsep}%
        \setlength{\parsep}{\bibparsep}}%
        \renewcommand*{\makelabel}[1]{\hss##1}
        }%
    {\endlist}%
  {\item}%
\fi
\makeatother
\begin{document}
% Tikz styles 
\tikzset{
  collacc0/.style={fill=blue!50!cyan},
  collacc1/.style={fill=magenta},
  collacc2/.style={fill=orange!90!black},
  collacc3/.style={fill=green!70!black},
  collacc4/.style={fill=blue!50!black},
}

\newcommand{\accmarkblue}{\begin{tikzpicture} \node[accset, collacc0] {}; \end{tikzpicture}}
\newcommand{\accmarkmag}{\begin{tikzpicture} \node[accset, collacc1] {}; \end{tikzpicture}}
\newcommand{\accmarkor}{\begin{tikzpicture} \node[accset, collacc2] {}; \end{tikzpicture}}
\newcommand{\accmarkred}{\begin{tikzpicture} \node[accset, collacc5] {}; \end{tikzpicture}}
\newcommand{\accmarkyell}{\begin{tikzpicture} \node[accset, collacc6] {}; \end{tikzpicture}}
\newcommand{\accmarkgr}{\begin{tikzpicture} \node[accset, collacc3] {}; \end{tikzpicture}}
\newcommand{\accmarkpink}{\begin{tikzpicture} \node[accset, collacc4] {}; \end{tikzpicture}}
\newcommand{\accsquaregr}{\begin{tikzpicture} \node[accsquare, collacc3] {}; \end{tikzpicture}}
\newcommand{\accsquareblue}{\begin{tikzpicture} \node[accsquare, collacc0] {}; \end{tikzpicture}}
\newcommand{\accsquaremag}{\begin{tikzpicture} \node[accsquare, collacc1] {}; \end{tikzpicture}}

\chapter{Introduction}
Our society has become heavily reliant on computer systems. Unexpected behavior of software often results merely in minor inconvenience. However is some cases, it might pose a threat to human safety. Therefore it is crucial to have the ability to verify if the software in question behaves as intended. 

One such verification method is model checking. The basic idea of this method is using finite state automata to accurately describe the behavior of the given program at any time during its execution. The states of the automaton represent the current state of the program, and the transitions between them describe how specific events shift the state of the program from one to another. To be able to describe programs that should never terminate, we use $\omega$-automata -- finite automata on infinite words. During the process of model checking, a product of two automata is created. It is desirable for the product to be as small as possible, which can be achieved by applying reduction methods to the original automata before creating their product.

For some reduction techniques, such as simulation-based reduction, it is beneficial to minimize the number of acceptance sets in the automaton. Babiak et al. \cite{spin2013} introduce the SCC-based simplifications of acceptance conditions. It is a method that proposes how to reduce the number of acceptance sets in \emph{transition-based generalized Büchi automata} (TGBA). For each strongly connected component, it evaluates the relation between acceptance sets and removes the useless ones. 

The goal of this thesis is to propose and implement an analogous simplification method for \emph{transition-based Emerson-Lei automata} (TELA). This method includes techniques to identify useless acceptance sets and modifications to the acceptance condition formula. During this process, we obtain separate acceptance condition formulae for each accepting SCC. Therefore, the presented method also describes how to merge these formulae into one. Finally, it describes the necessary modifications which ensure that the simplified automaton and the original automaton are equivalent. The desired outcome is to reduce the number of unique acceptance sets in the automaton. 

This thesis is structured into several chapters. Chapter two contains the basic definitions used throughout the thesis. Chapter three summarizes the ideas of the SCC-based simplification method for TGBA \cite{spin2013}. Chapter four presents the SCC-based simplification of TELA. Chapter five discusses the implementation of this method. Chapter six presents the results of experimental evaluation of the implemented tool. Chapter seven contains the conclusion. 

\chapter{Basic definitions}
\label{chap:basic_definitions}
This chapter presents the definitions of TELA and TGBA. The definition of the form of acceptance condition formulae of TGBA is more restricted than the form of TELA formulae; therefore, TELA are more complex. Consequently, research in the past mostly focused on TGBA.  In this chapter, we define TELA first because TGBA is a special case of TELA.

\section{Transition-based Emerson-Lei automaton (TELA)} 
\label{sec:tela}
A transition-based Emerson-Lei automaton, as defined by Bloemen et al. \cite{bloemen2017}, is a tuple $\mathcal{A} = (\Sigma, Q, q_0, \delta, Acc)$, where
\begin{itemize}
  \item $\Sigma$ is an alphabet,
  \item $Q$ is a finite set of states,
  \item $q_0 \in Q$ is the initial state,
  \item $\delta \subseteq Q \times \Sigma \times Q$ is a transition relation,
  \item $Acc$ is the acceptance condition formula, defined as a Boolean formula over terms of the form Fin$(T_i)$ or Inf$(T_i)$ for any acceptance set $T_i \subseteq \delta, i \in \{1, 2, \dots, n\}$. 
\end{itemize}

In figures, an acceptance set is represented by acceptance marks (for example \accmarkblue) placed on the transitions which belong to that set (as seen, for example, in Figure \ref{fig:tgba}). By convention, circle marks denote acceptance sets that appear in Inf-terms and square marks denote acceptance sets that appear in Fin-terms.

For a transition $t = (t^s, t^l, t^d) \in \delta$, $t^s$ denotes its source, $t^l$ its label and $t^d$ its destination.

A run of $\mathcal{A}$ over $\Sigma^\omega$ is defined as $\rho \in \delta^\omega$ where 
\begin{equation*}
  \rho(0)^s = q_0 \wedge \forall j \geq 0 \colon \rho(j)^d = \rho(j + 1)^s.
\end{equation*}

The acceptance of a run $\rho$ is defined by evaluating $Acc$ over $\rho$ where
\begin{itemize}
  \item Fin$(T_i)$ is \emph{true} if and only if all the transitions in $T_i$ occur finitely often in $\rho$, 
  \item Inf$(T_i)$ is \emph{true} if and only if some transition in $T_i$ occurs infinitely often in $\rho$.
\end{itemize}

An infinite word $w \in \Sigma^\omega$ is an infinite sequence of letters of $\Sigma$. Word $w$ is accepted by $\mathcal{A}$ if $Acc$ is evaluated as \emph{true} for the run of $\mathcal{A}$ over the word $w$. 

The language of $\mathcal{A}$ is a set of words $w$ such that $\mathcal{A}$ has an accepting run over $w$.

\section{Transition-based generalized Büchi automaton (TGBA)}
\label{sec:tgba}
A transition-based generalized Büchi automaton, as defined by Bloemen et al. \cite{bloemen2017}, is a TELA $\mathcal{A}_B = (\Sigma, Q, q_0, \delta, Acc)$ where for some $n$
\begin{equation*}
  Acc = \text{Inf}(T_1) \wedge \text{Inf}(T_2) \wedge \dots \wedge \text{Inf}(T_n).
\end{equation*} 
As follows from the definition of TELA, a run of a TGBA over an infinite word is accepting if, for all $i \in \{1, 2, \dots, n\}$, some transition in $T_i$ occurs infinitely often in the run of $\mathcal{A}_B$. 

\chapter{SCC-based simplification of acceptance conditions of TGBA} 
\label{chap:tgba_simpl}
This chapter summarizes the SCC-based simplifications of TGBA proposed by Babiak et al. \cite{spin2013}.

Let $\mathcal{A}_B$ be a TGBA with $n$ acceptance sets: 
\begin{equation*}
  Acc = \text{Inf}(T_1) \wedge \text{Inf}(T_2) \wedge \dots \wedge \text{Inf}(T_n).
\end{equation*}
Let $m$ be the number or accepting SCCs in $\mathcal{A}_B$ and let $A_1, \dots, A_m$ denote the sets of all transitions of $m$ accepting SCCs. Then $A_\delta = A_1 \cup \dots \cup A_m$ is the set of all transitions induced by the accepting SCCs\footnote{Transitions induced by an SCC are transitions such that their source and destination are both states of that SCC.} of $\mathcal{A}_B$. 
The suffix of any accepting run of $\mathcal{A}_B$ will be contained in some accepting SCC. Therefore any transitions that are not in $A_\delta$ can be removed from all acceptance sets of $\mathcal{A}_B$ without changing the language accepted by $\mathcal{A}_B$. We can modify the acceptance sets of $\mathcal{A}_B$ as follows: 
\begin{equation*}
  Acc = \text{Inf}(T_1 \cap A_\delta) \wedge \text{Inf}(T_2 \cap A_\delta) \wedge \dots \wedge \text{Inf}(T_n \cap A_\delta).
\end{equation*}
If $Acc$ contains such sets that $T_i \subseteq T_j$ and $i \neq j$, we can remove $T_j$, because any run that visits $T_i$ infinitely often also visits $T_j$ infinitely often. Therefore, removing $T_j$ will not change the language.
For each accepting SCC, we can define a set of indices of useless acceptance sets 
\begin{equation*}
  \begin{aligned}
    U_k = &\{ j \in \{1, 2, \dots, n\} \mid \exists i \in \{1, 2, \dots, n\}, \\
    &(T_i \cap A_k \subsetneq T_j \cap A_k) \vee (T_i \cap A_k = T_j \cap A_k \wedge j > i)\},
  \end{aligned}
\end{equation*}
where $k$ denotes the index of the SCC.

If the two sets $T_i$ and $T_j$ are equal, then, by this definition, only one of their indices belongs to $U_k$, ensuring that one of the sets will be preserved. The set of indices of needed acceptance sets for any accepting SCC is $N_k = \{1, 2, \dots, n\} \smallsetminus U_k$. 

This may result in each SCC having a different number of acceptance sets, however the automaton as a whole can only have one set of acceptance sets. The number of acceptance sets needed in the simplified automaton is $n' = max_{k \in \{1, 2, \dots, n\}} |N_k|$. Let $N'_k$ be a copy of $N_k$. By adding $n' - |N_k|$ indices from $U_k$ to $N'_k$, we ensure that $|N'_k| = n'$ for each accepting SCC. Let $\alpha_k \colon \{1, \dots, n'\} \to N'_k$ be any bijection. Now we can define the new acceptance sets of the simplified automaton as
\begin{equation*}
  T'_i = \underset{k \in \{1, \dots, m\}}\bigcup (T_{\alpha_k(i)} \cap A_k)
\end{equation*}
in acceptance condition formula $Acc = \text{Inf}(T'_1) \wedge \text{Inf}(T'_2) \wedge \dots \wedge \text{Inf}(T'_{n'})$.

\bigskip
\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \tikzstyle{every state}=[very thick]
      \node[state, initial above]   (0) at (0,0) {0};
      \node[state]            (1) at (-3, 0) {1};
      \node[state]            (2) at (3, 0) {2};

      \path[->, very thick]
              (0) edge[bend right]  node [above] {\texttt{tt}} (1) 
                  edge[bend left]   node [above] {\texttt{tt}} (2) 
              (1) edge[loop above]  node[above] {$ab$} node[accset, collacc1, pos=0.40] {} node[accset, collacc0, pos=0.15] {} node[accset, collacc2, pos=0.75] {} (1) 
                  edge[loop left]   node[left] {$a\overline{b}$} node[accset, collacc1] {} node[accset, collacc2, pos=0.15] {} (1) 
                  edge[loop right]  node[right] {$\overline{a}\overline{b}$} node[accset, collacc1] {} (1) 
                  edge[loop below]  node[below] {$\overline{a}b$} node[accset, collacc1] {} node[accset, collacc0, pos=0.15] {} (1) 
              (2) edge[loop above]  node[above] {$c$} node[accset, collacc1, pos=0.40] {} node[accset, collacc0, pos=0.15] {} node[accset, collacc2, pos=0.75] {} (2) 
                  edge[loop below]  node[below] {$\overline{c}$} node[accset, collacc0] {} node[accset, collacc2, pos=0.15] {} (2);    
    \end{tikzpicture}
    \caption{TGBA with three acceptance sets}
    \label{fig:tgba}
  \end{center}
\end{figure}

\begin{figure}[h]
    \begin{center}
    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \tikzstyle{every state}=[very thick]
      \node[state, initial above]   (0) at (0,0) {0};
      \node[state]            (1) at (-3, 0) {1};
      \node[state]            (2) at (3, 0) {2};

      \path[->, very thick]
              (0) edge[bend right]  node [above] {\texttt{tt}} (1) 
                  edge[bend left]   node [above] {\texttt{tt}} (2) 
              (1) edge[loop above]  node[above] {$ab$} node[accset, collacc0, pos=0.15] {} node[accset, collacc2] {} (1) 
                  edge[loop left]   node[left] {$a\overline{b}$} node[accset, collacc2] {} (1) 
                  edge[loop right]  node[right] {$\overline{a}\overline{b}$} (1) 
                  edge[loop below]  node[below] {$\overline{a}b$} node[accset, collacc0] {} (1) 
              (2) edge[loop above]  node[above] {$c$} node[accset, collacc0, pos=0.15] {} node[accset, collacc2] {} (2) 
                  edge[loop below]  node[below] {$\overline{c}$} node[accset, collacc2] {} (2);    
    \end{tikzpicture}
    \caption{TGBA from Figure \ref{fig:tgba} after SCC-based acceptance simplification}
    \label{fig:simpl_tgba}
  \end{center}
\end{figure}

In Figure \ref{fig:tgba} there is a TGBA with two accepting SCCs. Let $S_1$ be the SCC comprised of state 1 and $S_2$ be the SCC comprised of state 2. The set of useless acceptance sets for $S_1$ is $U_1 = \{\accmarkmag\}$, because $\accmarkblue \subseteq \accmarkmag$ (and also $\accmarkor \subseteq \accmarkmag$). For $S_2$ it is $U_2 = \{\accmarkblue, \accmarkor\}$, because $\accmarkmag \subseteq \accmarkblue$ and $\accmarkmag \subseteq \accmarkor$. 

The sets of needed acceptance sets for $S_1, S_2$ are $N_1 = \{\accmarkblue, \accmarkor\}$, $N_2 = \{\accmarkmag\}$, respectively. The number of needed acceptance sets for the whole automaton is $n' = 2$. We define $N'_1 = N_1, N'_2 = N_2 \cup \{\accmarkor\}, \alpha_1 (\accmarkor) = \accmarkor, \alpha_1 (\accmarkblue) = \accmarkblue, \alpha_2 (\accmarkor) = \accmarkor, \alpha_2 (\accmarkblue) = \accmarkmag$. The result is the TGBA in Figure \ref{fig:simpl_tgba}.


\chapter{SCC-based simplification of acceptance conditions of TELA}
\label{chap:simpl_tela}
This chapter presents the proposed simplification method for TELA. The first section describes the process of analyzing SCCs. The second section covers the removal of useless transitions from all acceptance sets. The third section proposes several techniques that may remove useless acceptance sets from SCCs selected based on the analysis in Section \ref{sec:init_analysis}. Section \ref{sec:merging_formulae} presents the method used for merging the separate acceptance condition formulae of all SCCs into one. The resulting formula is the acceptance condition of the simplified automaton. This section also covers how to identify and resolve possible conflicts caused by dependencies between disjuncts. Section \ref{sec:restore_equiv} describes the necessary modifications to the simplified automaton that ensure its equivalence with the input automaton. 

In this chapter, let the input TELA have at least one acceptance set. Let the acceptance condition formula of the TELA be in disjunctive normal form (DNF). When referring to the whole automaton, we use the notation $\mathcal{A}$. $Acc$ denotes the acceptance condition formula of the whole automaton. $\mathcal{A'}$ refers to an SCC of the original automaton, run of $\mathcal{A'}$ denotes the run of $\mathcal{A}$ such that the suffix of that run is contained within $\mathcal{A'}$. $Acc'$ refers to the acceptance condition formula of $\mathcal{A'}$.

If there occurs a situation such that we remove the only occurrence of an acceptance set $T_i$ in some $Acc'$, then we remove the marks that denote $T_i$ from the transitions of $\mathcal{A'}$. In other words, if some $Acc'$ no longer contains $T_i$ in any terms, then the marks denoting $T_i$ are not needed in $\mathcal{A'}$.

Because the formula is in DNF, we can represent it as 
\begin{equation*}
  Acc = \{d_1, d_2, \dots, d_m\},
\end{equation*}
where each $d_k$ is a disjunct. Further, each such disjunct $d_k$ is represented as a set of conjuncts. For example, formula $Acc_e = (\text{Inf}(T_1) \wedge \text{Fin}(T_2)) \vee (\text{Inf}(T_3))$ is represented by $Acc_e = \{d_1, d_2\}$, where $d_1 = \{\text{Inf}(T_1), \text{Fin}(T_2)\}, d_2 = \{\text{Inf}(T_3)\}$. 

Let $S$ be the set of states of $\mathcal{A'}$. Then $\delta_{\mathcal{A'}} = \{t \in \delta \mid t^s \in S \wedge t^d \in S\}$ is the set of all transitions of that SCC. In other words, $\delta_{\mathcal{A'}}$ is a set of all transitions in $\mathcal{A'}$.

\section{Initial analysis of SCCs}
\label{sec:init_analysis}
Before applying any simplification techniques, we first analyze each SCC and assign it one of the following attributes: \emph{always accepting}, \emph{never accepting}, \emph{maybe accepting}. The purpose of this classification is to determine the necessary modifications when restoring equivalence with the original automaton, as described in Section \ref{sec:restore_equiv}. 

Let $T_{all} = \{i \in \{1, 2, \dots, n\} \mid \forall t \in \delta_{\mathcal{A'}} \colon t \in T_i \}$ be the set of indices of acceptance sets that contain all transitions of the SCC.

Let $T_{any} = \{i \in \{1, 2, \dots, n\} \mid \exists t \in \delta_{\mathcal{A'}} \colon t \in T_i \}$ be the set of indices of acceptance sets that contain at least one transition of the SCC.

Let $Acc'$ be a copy of $Acc$. Let $T_i, i \in \{1, 2, \dots, n\}$ be an acceptance set of $\mathcal{A}$. Now we perform the following substitutions for each disjunct $d_k$ in $Acc'$. 
\begin{itemize}
  \item If $i \in T_{all}$ then we substitute \emph{true} for Inf$(T_i)$.
  \item If $i \in T_{all}$ then we substitute \emph{false} for Fin$(T_i)$.
  \item If $i \notin T_{any}$ then we substitute \emph{false} for Inf$(T_i)$.
  \item If $i \notin T_{any}$ then we substitute \emph{true} for Fin$(T_i)$.
\end{itemize}

Any disjunct in $Acc'$ that only contains \emph{true} is evaluated as \emph{true}. Any disjunct in $Acc'$ that contains at least one \emph{false} is evaluated as \emph{false}. 

If any disjunct in $Acc'$ equals \emph{\{true\}}, then the SCC is \emph{always accepting}. If all disjuncts in $Acc'$ are equal to \emph{\{false\}}, then the SCC is \emph{never accepting}. If neither of the above conditions applies, then the SCC is \emph{maybe accepting}.

In Figure \ref{fig:analysis}, there are examples of SCCs and the results of their analysis.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (0, 2.5) {Inf\accmarkblue};
      \node[state, initial]   (0) at (0,0) {};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$a$} node[accset, collacc0] {} (0)
              (0) edge[loop below]  node[below] {$b$} node[accset, collacc0] {} (0)
              (0) edge[loop right]  node[right] {$\overline{a}$} node[accset, collacc0] {} (0);            
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (0, 2.5) {Inf\accmarkblue$\ \wedge\ $Fin\accsquaremag}; 
    \node[state, initial]   (0) at (0,0) {};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$a$} node[accset, collacc0] {} (0)
            (0) edge[loop below]  node[below] {$b$} (0)
            (0) edge[loop right]  node[right] {$\overline{b}$} (0);            
\end{tikzpicture}
\begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
  \node[flabel] (pigfq) at (0, 2.5) {Inf\accmarkblue$\ \vee\ $Fin\accmarkmag}; 
  \node[state, initial]   (0) at (0,0) {};

  \path[->, very thick]
          (0) edge[loop above]  node[above] {$a$} node[accsquare, collacc1] {} (0)
          (0) edge[loop below]  node[below] {$b$} node[accsquare, collacc1] {} (0);  
\end{tikzpicture}
  \caption{Examples of SCC analysis: SCC on the left is \emph{always accepting}. SCC in the middle is \emph{maybe accepting}, Fin\protect \accsquaremag \ is evaluated as \emph{true}. SCC on the right is \emph{never accepting}. Both Inf\protect \accmarkblue \ and Fin\protect \accsquaremag \ are evaluated as \emph{false}.}
  \label{fig:analysis}
\end{figure}

\section{Removing useless transitions from acceptance sets}
\label{sec:remove_out_transition}
Any accepting run of $\mathcal{A}$ has a suffix contained within an accepting SCC. Let $T_{o}$ be a set of all transitions outside of accepting SCCs. Such transitions can be removed from all acceptance sets without changing the language, because transitions outside of accepting SCCs are always visited finitely often by any accepting run of $\mathcal{A}$. Therefore, removing such transition $t_{o} \in T_i, i \in \{1, 2, \dots, n\}$ never changes the boolean value of Inf$(T_i)$, Fin$(T_i)$.

We can modify each acceptance set $T_i, i \in \{1, 2, \dots, n\}$ of $Acc$ as follows:
\begin{equation*}
  T_i \coloneqq T_i \smallsetminus T_{o}.
\end{equation*}

Example of this simplification is in Figure \ref{fig:remove_useless}.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (0, 2) {Inf\accmarkblue$\ \wedge\ $Fin\accsquaremag};
      \node[state, initial]   (0) at (0,0) {0};
      \node[state]            (1) at (2.5, 0) {1};

      \path[->, very thick]
              (0) edge[]  node [above] {$a$} node[accset, collacc0, pos=0.30] {} node[accsquare, collacc1, pos=0.70] {} (1) 
              (1) edge[loop above]  node[above] {$\overline{b}$} node[accset, collacc0] {} (1)
              (1) edge[loop below]  node[below] {$b$} node[accsquare, collacc1] {} (1)
              (1) edge[loop right]  node[right] {$\overline{a}$} (1);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (0, 2) {Inf\accmarkblue$\ \wedge\ $Fin\accsquaremag};
    \node[state, initial]   (0) at (0,0) {0};
    \node[state]            (1) at (2.5, 0) {1};

    \path[->, very thick]
            (0) edge[]  node [above] {$a$} (1) 
            (1) edge[loop above]  node[above] {$\overline{b}$} node[accset, collacc0] {} (1)
            (1) edge[loop below]  node[below] {$b$} node[accsquare, collacc1] {} (1)
            (1) edge[loop right]  node[right] {$\overline{a}$} (1);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) applying modification from Section \ref{sec:remove_out_transition}.}
  \label{fig:remove_useless}
\end{figure}


\section{SCC simplifications}
This section presents the simplification methods that can be applied to all SCCs that are \emph{maybe accepting}. Using these methods on \emph{always accepting} or \emph{never accepting} SCCs is not necessary because the acceptance formulae of such SCCs can be replaced with \emph{true} or \emph{false}, respectively. 

Unlike TGBA, TELA have complex acceptance formulae. Therefore, to identify which acceptance sets are useless, we need to consider not only the relation between the transitions in these sets but also the specifics of their occurrence in the acceptance condition formula. 

For example, consider acceptance sets $T_1, T_2, T_3$, where $T_1 \subseteq T_2$, and the formula $Acc_a = \{\{\text{Inf}(T_1), \text{Inf}(T_2)\}\}$. In this case, we can apply the simplifications described in Chapter \ref{chap:tgba_simpl} and remove $T_2$, because the form of $Acc_a$ is identical with the form of TGBA acceptance formula. However, in $Acc_b = \{\{\text{Inf}(T_1)\}, \{\text{Inf}(T_2), \text{Fin}(T_3)\}\}$ removing $T_2$ could change the language. This example demonstrates that for SCC-based TELA simplifications, it is necessary to carefully define the requirements about the form of the acceptance condition formula.

\subsection{Acceptance condition formula modifications}
In the previous section, we proposed several substitutions used to analyze the SCCs. By using a similar approach, we can remove useless disjuncts from $Acc'$, and useless conjuncts from the remaining disjuncts.

Let $T_i$ be an acceptance set that appears in $Acc'$ in terms Fin$(T_i)$. If all transitions of $\mathcal{A'}$ belong to $T_i$, then during a run of $\mathcal{A'}$ at least one transition of $T_i$ is visited infinitely often. Therefore Fin$(T_i)$ is always \emph{false} for any run of $\mathcal{A'}$. Any disjunct $d_k$ of $Acc'$ that contains Fin$(T_i)$ can be removed without changing the language.

More formally, if $T_i \supseteq \delta_{\mathcal{A'}}$ holds for some $i \in \{1,2, \dots, n\}$, then we can define the set of useless disjuncts as
\begin{equation*}
  U = \{d_k \in Acc' \mid \text{Fin}(T_i) \in d_k \}
\end{equation*}
and remove it from $Acc'$:
\begin{equation*}
  Acc' \coloneqq Acc' \smallsetminus U.
\end{equation*}

Figure \ref{fig:rem_dis_fin} shows an example of this modification.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-2.5, 1) {Inf\accmarkblue$\ \vee\ $Fin\accsquaremag};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{b}$} node[accsquare, collacc1] {} (0)
              (0) edge[loop below]  node[below] {$b$} node[accset, collacc0, pos=0.15] {} node[accsquare, collacc1] {} (0)
              (0) edge[loop right]  node[right] {$a$} node[accsquare, collacc1] {} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Inf\accmarkblue}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{b}$} (0)
            (0) edge[loop below]  node[below] {$b$} node[accset, collacc0] {}(0)
            (0) edge[loop right]  node[right] {$a$} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) removing useless disjuncts.}
  \label{fig:rem_dis_fin}
\end{figure}

Let $T_i$ be an acceptance set that appears in $Acc'$ in terms Inf$(T_i)$. If $T_i$ does not contain any transitions of $\mathcal{A'}$, then any disjunct $d_k$ in $Acc'$ that contains Inf$(T_i)$ can be removed. Removing $d_k$ does not change the language, because any run of $\mathcal{A'}$ does not visit any transitions that belong to $T_i$; therefore, Inf$(T_i)$ is never satisfied.

Formally, if $T_i \cap \delta_{\mathcal{A'}} = \emptyset$ holds for some $i \in \{1,2, \dots, n\}$, then 
\begin{equation*}
  U = \{d_k \in Acc' \mid \text{Inf}(T_i) \in d_k \}
\end{equation*}
is the set of useless disjuncts that can be removed from $Acc'$:
\begin{equation*}
  Acc' \coloneqq Acc' \smallsetminus U.
\end{equation*}

Example of this modification is in Figure \ref{fig:rem_dis_inf}

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-2.5, 1) {Inf\accmarkblue$\ \vee\ $Fin\accsquaremag};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{b}$} node[accsquare, collacc1] {} (0)
              (0) edge[loop below]  node[below] {$b$} (0)
              (0) edge[loop right]  node[right] {$a$} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Fin\accsquaremag}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{b}$} node[accsquare, collacc1] {} (0)
            (0) edge[loop below]  node[below] {$b$} (0)
            (0) edge[loop right]  node[right] {$a$} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) removing useless disjuncts.}
  \label{fig:rem_dis_inf}
\end{figure}

If an acceptance set $T_i$ contains all transitions of the SCC, then Inf$(T_i)$ is always evaluated as \emph{true}. Therefore Inf$(T_i)$ can be removed from all disjuncts of $Acc'$ without changing the language. 
In other words, we can define a set of useless conjuncts 
\begin{equation*}
  U = \{\text{Inf}(T_i) \mid i \in \{1,2, \dots, n\} \wedge T_i \supseteq \delta_{\mathcal{A'}}\}.
\end{equation*}
Then we can remove the useless conjuncts in $U$ from each disjunct of $Acc'$ as follows:
\begin{equation*}
  Acc' = \{d_1 \smallsetminus U, d_2 \smallsetminus U, \dots, d_m \smallsetminus U\}.
\end{equation*}

Similarly, Fin$(T_i)$ is always \emph{true} if no transitions of the SCC belong to $T_i$. Therefore all such Fin$(T_i)$ can be removed from $Acc'$ without changing the language.
The set of useless conjuncts can be defined as:
\begin{equation*}
  U = \{\text{Fin}(T_i) \mid i \in \{1,2, \dots, n\} \wedge T_i \cap \delta_{\mathcal{A'}} = \emptyset\}.
\end{equation*}
Then the $Acc'$ can be modified as follows:
\begin{equation*}
  Acc' = \{d_1 \smallsetminus U, d_2 \smallsetminus U, \dots, d_m \smallsetminus U\}.
\end{equation*}

Let $d_k, d_l$ be disjuncts of $Acc'$ such that $d_k \subseteq d_l$. In this case, disjunct $d_l$ can be removed from $Acc'$, because either $d_k$ is satisfied and the whole formula is evaluated as \emph{true} regardless of $d_l$, or $d_k$ is not satisfied, in which case $d_l$ is also not satisfied. Therefore, removing $d_l$ does not change the language.

More formally, if we define the set of useless disjuncts as:
\begin{equation*}
  U = \{d_l \in Acc' \mid \exists d_k \in Acc' \colon d_k \neq d_l \wedge d_k \subseteq d_l\},
\end{equation*}
then we may remove these useless disjuncts from $Acc'$ as follows:
\begin{equation*}
  Acc' \coloneqq Acc' \smallsetminus U.
\end{equation*}

\subsection{Inclusion-based simplifications}
%Inf & Inf
We can modify the simplifications from Chapter \ref{chap:tgba_simpl} to make them viable for TELA by adding a prerequisite that demands a specific form of the acceptance formula. Let $T_i \subseteq T_j$ be two distinct acceptance sets that appear in the acceptance condition formula in terms Inf$(T_i)$ and Inf$(T_j)$. Let $Acc'$ be in such form that in any disjunct of the formula, either both Inf$(T_i), \text{Inf}(T_j)$ are present, or neither is present. If the required conditions are met, we may remove $T_j$ from the formula. 

More formally, if the following conditions hold
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\} \wedge i \neq j$,
  \item $T_i \cap \delta_{\mathcal{A'}} \subsetneq T_j \cap \delta_{\mathcal{A'}} \vee (T_i \cap \delta_{\mathcal{A'}} = T_j \cap \delta_{\mathcal{A'}} \wedge j > i)$,
  \item $\forall d_k \in Acc' \colon (\text{Inf}(T_i) \in d_k \Leftarrow \text{Inf}(T_j) \in d_k)$,
\end{itemize}
then we can remove Inf$(T_j)$ from $Acc'$: 
\begin{equation*}
  Acc' = \{d_1 \smallsetminus \{\text{Inf}(T_j)\}, d_2 \smallsetminus \{\text{Inf}(T_j)\}, \dots, d_m \smallsetminus \{\text{Inf}(T_j)\}\}.
\end{equation*} 

Example of this simplification is in Figure \ref{fig:inclusion_infs}.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-2.5, 1) {Inf\accmarkblue$\ \wedge\ $Inf\accmarkmag};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{a}$} node[accset, collacc0] {} node[accset, collacc1, pos=0.15] {} (0)
              (0) edge[loop below]  node[below] {$b$} node[accset, collacc0] {} (0)
              (0) edge[loop right]  node[right] {$a$} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Inf\accmarkmag}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{a}$} node[accset, collacc1] {} (0)
            (0) edge[loop below]  node[below] {$b$} (0)
            (0) edge[loop right]  node[right] {$a$} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) using inclusion based simplification.}
  \label{fig:inclusion_infs}
\end{figure}

%Fin & Fin
Let $T_i \subseteq T_j$ be two distinct acceptance sets that appear in $Acc'$ in terms Fin$(T_i)$ and Fin$(T_j)$. If each disjunct in $Acc'$ either contains both Fin$(T_i)$ and Fin$(T_j)$ or contains neither of them, then Fin$(T_i)$ can be removed from $Acc'$.  Removing Fin$(T_i)$ does not change the language, because when transitions in $T_j$ are visited finitely often during a run of $\mathcal{A'}$, then also transitions in $T_i$ are visited finitely often. 

In other words, if these conditions are met:
\begin{itemize}
  \item $i, j \in \{1,2, \dots, n\} \wedge i \neq j$,
  \item $T_i \cap \delta_{\mathcal{A'}} \subsetneq T_j \cap \delta_{\mathcal{A'}} \vee (T_i \cap \delta_{\mathcal{A'}} = T_j \cap \delta_{\mathcal{A'}} \wedge j > i)$,
  \item $\forall d_k \in Acc' \colon (\text{Fin}(T_i) \in d_k \Rightarrow \text{Fin}(T_j) \in d_k)$,
\end{itemize}
then Fin$(T_i)$ can be removed from $Acc'$:
\begin{equation*}
  Acc' = \{d_1 \smallsetminus \{\text{Fin}(T_i)\}, d_2 \smallsetminus \{\text{Fin}(T_i)\}, \dots, d_m \smallsetminus \{\text{Fin}(T_i)\}\}.
\end{equation*}

See an example of this simplification in Figure \ref{fig:inclusion_fins}.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-2.5, 1) {Fin\accsquareblue$\ \wedge\ $Fin\accsquaremag};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{b}$} (0)
              (0) edge[loop below]  node[below] {$a$} node[accsquare, collacc0] {} (0)
              (0) edge[loop right]  node[right] {$b$} node[accsquare, collacc0] {} node[accsquare, collacc1, pos=0.15] {} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Fin\accsquareblue}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{b}$} (0)
            (0) edge[loop below]  node[below] {$a$} node[accsquare, collacc0] {} (0)
            (0) edge[loop right]  node[right] {$b$} node[accsquare, collacc0] {} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) using inclusion based simplification.}
  \label{fig:inclusion_fins}
\end{figure}

%Inf & Fin
Let $T_i \subseteq T_j$ be two distinct acceptance sets that appear in $Acc'$ in terms Inf$(T_i)$ and Fin$(T_j)$. If there is such disjunct $d_k$ of $Acc'$, that it contains both Inf$(T_i)$ and Fin$(T_j)$, then $d_k$ can be removed from $Acc'$. Removing $d_k$ does not change the language, because any run of $\mathcal{A'}$ that visits $T_j$ finitely often cannot visit any transition in $T_i$ infinitely often. Therefore $d_k$ is evaluated as \emph{false} for any run of $\mathcal{A'}$. 

If the following conditions hold
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\} \wedge i \neq j$,
  \item $T_i \cap \delta_{\mathcal{A'}} \subsetneq T_j \cap \delta_{\mathcal{A'}} \vee (T_i \cap \delta_{\mathcal{A'}} = T_j \cap \delta_{\mathcal{A'}} \wedge j > i)$,
\end{itemize}
then the we can define the set of useless disjuncts as:
\begin{equation*}
  U = \{d_k \in Acc' \mid \text{Inf}(T_i) \in d_k \wedge \text{Fin}(T_j) \in d_k \}.
\end{equation*}
$Acc'$ without these useless sets is defined as:
\begin{equation*}
  Acc' \coloneqq Acc' \smallsetminus U.
\end{equation*}

Example of this simplification is shown in Figure \ref{fig:inclusion_remdis}.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-3, 1) {Inf\accmarkor$\ \vee\ $(Fin\accsquaremag$\ \wedge\ $Inf\accmarkblue)};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{a}$} node[accsquare, collacc1] {} (0) 
              (0) edge[loop below]  node[below] {$a$} node[accset, collacc0] {} node[accsquare, collacc1, pos=0.15] {} (0)
              (0) edge[loop right]  node[right] {$b$} node[accset, collacc2] {} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Inf\accmarkor}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{a}$} (0)
            (0) edge[loop below]  node[below] {$a$} (0)
            (0) edge[loop right]  node[right] {$b$} node[accset, collacc2] {} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) removing useless disjuncts based on inclusion od acceptance sets.}
  \label{fig:inclusion_remdis}
\end{figure}

\subsection{Simplification of complementary acceptance sets}
Let $T_i$ and $T_j$ be two distinct acceptance sets that appear in $Acc'$ in terms Fin$(T_i)$ and Inf$(T_j)$. Let $T_i$ and $T_j$ be complementary. If each $d_k$ of $Acc'$ that contains Inf$(T_j)$ also contains Fin$(T_i)$, then we can remove Inf$(T_j)$ without changing the language. If during a run of $\mathcal{A'}$ all transitions in $T_i$ are visited finitely often, then necessarily at least one transition in $T_j$ is visited infinitely often. Therefore keeping only the conjunct Fin$(T_i)$ in $d_k$ is sufficient. 

More formally, if these conditions are met:
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\} \wedge i \neq j$,
  \item $\exists T_i, T_j \colon \delta_{\mathcal{A'}} \smallsetminus T_i = T_j$,
  \item $\forall d_k \in Acc' \colon \text{Inf}(T_j) \in d_k \Rightarrow \text{Fin}(T_j) \in d_k$,
\end{itemize}
then Inf$(T_j)$ can be removed from $Acc'$:
\begin{equation*}
  Acc' = \{d_1 \smallsetminus \{\text{Inf}(T_j)\}, d_2 \smallsetminus \{\text{Inf}(T_j)\}, \dots, d_m \smallsetminus \{\text{Inf}(T_j)\} \}
\end{equation*}

In Figure \ref{fig:complementary}, there is an example of this simplification.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-2.5, 1) {Fin\accsquaremag$\ \wedge\ $Inf\accmarkblue};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{a}$} node[accsquare, collacc1] {} (0) 
              (0) edge[loop below]  node[below] {$b$} node[accset, collacc0] {} (0)
              (0) edge[loop right]  node[right] {$a$} node[accset, collacc0] {} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Fin\accsquaremag}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{a}$} node[accsquare, collacc1] {} (0)
            (0) edge[loop below]  node[below] {$b$} (0)
            (0) edge[loop right]  node[right] {$a$} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) simplification of complementary sets.}
  \label{fig:complementary}
\end{figure}

\subsection{Combining Fin conjuncts}
\label{subsec:combine_fins}
If $\mathcal{A'}$ has such acceptance sets $T_i, T_j$ and $i \neq j$, that both sets appear in $Acc'$ in terms Fin$(T_i)$ and Fin$(T_j)$ and each disjunct of $Acc'$ either contains both of them or neither of them, then we can replace these sets by a new acceptance set. The new acceptance set $T_x$ contains all transitions from both $T_i$ and $T_j$. Fin$(T_i)$ and Fin$(T_j)$ can be removed from all disjuncts, that they belong to, and Fin$(T_x)$ is added to those disjuncts. This modification does not change the language, because Fin$(T_x)$ is equivalent to the expression $\text{Fin}(T_i) \wedge \text{Fin}(T_j)$, if $T_x = T_i \cup T_j$. Either expression is satisfied only if all transitions in $T_x = T_i \cup T_j$ are visited finitely often.

In other words, if the following conditions are met
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\} \wedge i \neq j$,
  \item $\forall d_k \in Acc' \colon \text{Fin}(T_i) \in d_k \Leftrightarrow \text{Fin}(T_j) \in d_k$,
\end{itemize}
then we can define a new acceptance set $T_x = T_i \cup T_j$ and modify $Acc'$ as follows: 
\begin{align*}
  Acc' \coloneqq& \{d_k \in Acc' \mid \text{Fin}(T_i) \notin d_k\} \cup \\ &\{(d_k \smallsetminus \{\text{Fin}(T_i), \text{Fin}(T_j)\}) \cup \{\text{Fin}(T_x)\} \mid \text{Fin}(T_i) \in d_k\}.
\end{align*}

In Figure \ref{fig:combine_fins}, there is an example of this simplification.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (-3, 1) {Fin\accsquareblue$\ \wedge\ $Fin\accsquaremag};
      \node[state, initial]   (0) at (0,0) {0};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$\overline{b}$} node[accsquare, collacc1] {} (0) 
              (0) edge[loop below]  node[below] {$\overline{a}$} node[accsquare, collacc0] {} (0)
              (0) edge[loop right]  node[right] {$b$} (0);
              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (2, 1) {Fin\accsquaregr}; 
    \node[state, initial]   (0) at (0,0) {0};

    \path[->, very thick]
            (0) edge[loop above]  node[above] {$\overline{b}$} node[accsquare, collacc3] {} (0)
            (0) edge[loop below]  node[below] {$\overline{a}$} node[accsquare, collacc3] {} (0)
            (0) edge[loop right]  node[right] {$b$} (0);
            
\end{tikzpicture}
  \caption{TELA before (left) and after (right) combining sets that appear in Fin-terms as described in \protect \ref{subsec:combine_fins}.}
  \label{fig:combine_fins}
\end{figure}

\section{Merging acceptance condition formulae of all SCCs}
\label{sec:merging_formulae}
After applying simplification techniques from the previous chapter, each SCC has its own acceptance formula. This section proposes one possible approach to merging acceptance condition formulae. The resulting formula is the acceptance condition formula of the simplified automaton $\mathcal{A}_s$.

This method only processes the formulae of \emph{maybe accepting} SCCs. The formulae of \emph{never accepting} and \emph{always accepting} SCCs are equivalent to expressions \emph{false} and \emph{true}, respectively. These expressions can merge with any formula without it requiring any modifications. Therefore, it is not necessary to include them in the merging process. However, after the merging process is complete, it is necessary to modify the automaton so that all runs of the original automaton $\mathcal{A}$ and of the simplified automaton $\mathcal{A}_S$ such that the suffix is contained within the \emph{never accepting} SCCs or \emph{always accepting} SCCs are evaluated the same. 

Let $C = \{\delta_1, \delta_2, \dots, \delta_z\}$ be the set containing sets of all transitions of \emph{maybe accepting} SCCs of $\mathcal{A}$. The set of acceptance condition formulae of the SCCs is $F = \{Acc_1, Acc_2, \dots, Acc_z\}$. Let $F$ be a sorted set with the formulae ordered by their cardinality in descending order, meaning that the first is a formula with the maximal number of disjuncts. Let $C$ be sorted so that the sets of transitions of SCCs match the order of their respective formulae in $F$. In other words, the first formula in $F$, $Acc_1$, belongs to SCC with transitions $\delta_1$.

We select $Acc_1$, the formula with the maximal cardinality, to be the base for the new acceptance condition formula $Acc_s$. Let $Acc_s$ be a copy of $Acc_1$ and let $\delta_s$ be an alias for $\delta_1$. Then we can remove $Acc_1$ from $F$ and $\delta_1$ from $C$. This method modifies $Acc_s$ so that we may define an injective function $\varphi$ for any formula $Acc_k \in F$ that maps the acceptance sets of $Acc_k$ to the sets of $Acc_s$. 

We refer to the situation when a formula contains the same acceptance set in two or more disjuncts as \emph{dependency}. In the process of merging formulae, dependencies in $Acc_s$ may lead to undesired changes in the language accepted by the automaton. Resolving the situations when such changes may occur is described in Subsection \ref{subsec:resolve_conflicts}. 

Merging formulae consists of merging each formula in $C$ with $Acc_s$. When the process is complete, the modified $Acc_s$ becomes the acceptance formula of the whole automaton $\mathcal{A}_s$.

\subsection{Disjunct pairing}
Two formulae are merged by pairing their disjuncts and then pairing the conjuncts in the paired disjuncts. The pairing of disjuncts is selected based on the lowest cost, meaning we choose the pairing that requires adding the fewest new conjuncts to $Acc_s$. 

Determining the lowest cost pairing is a form of assignment problem. There are several possible solutions. Our implementation uses the Hungarian method \cite{hungarian_method}. The input for this method is a square matrix $M$. Each element in $M$ represents the cost of merging two disjuncts, $d_k \in Acc_k$ and $d_s \in Acc_s$. The cost is calculated as the number of Fin-terms in $d_k$ subtracted from the number of Fin-terms in $d_s$ plus the number of Inf-terms in $d_k$ subtracted from the number of Inf-terms in $d_s$. If $Acc_k$ has fewer disjuncts than $Acc_s$, then we calculate the cost with $d_k = \emptyset$. The cost of any pairing cannot be lower than 0, because it denotes the number or conjuncts that we need to add to $d_s$. The rows of $M$ correspond to the disjuncts of $Acc_s$, and the columns correspond to the disjuncts of $Acc_k$.

More formally, the cost $c$ of merging disjuncts $d_s \in Acc_s$ and $d_k \in Acc_k$ is defined as:
\begin{equation*}
  c = (f(d_s) - f(d_k)) + (i(d_s) - i(d_k)),
\end{equation*}
where $f$ denotes the number of Fin-terms and $i$ denotes the number of Inf-terms in the corresponding disjuncts.

For example, consider
\begin{equation*}
  Acc_s = \{\{\text{Inf}(T_1), \text{Inf}(T_4), \text{Inf}(T_6), \text{Fin}(T_2)\}, \{\text{Inf}(T_3)\}, \{\text{Inf}(T_5), \text{Fin}(T_7)\}\},
\end{equation*}
\begin{equation*}
  Acc_k = \{\{\text{Inf}(T_8), \text{Inf}(T_9), \text{Fin}(T_{10})\}, \{\text{Fin}(T_{11}) \}\},
\end{equation*}
then the matrix $M=$
\begin{bmatrix}
  0 & 0 & 0\\
  2 & 1 & 0\\
  1 & 0 & 0\\
\end{bmatrix}
and it determines the following pairing: $(1, 1), (2, 3), (3, 2)$, where the first element of the tuple denotes the index of a disjunct in $Acc_s$ and the second element denotes the index of a disjunct in $Acc_k$.

\subsection{Merging two disjuncts}
The Hungarian method determines that we pair disjuncts $d_s$ and $d_k$, where $d_s$ is a disjunct of $Acc_s$ and $d_k$ is a disjunct of $Acc_k$. 

First we label all conjuncts in $d_s$ as unused. Then we try to pair each conjunct in $d_k$ with a conjunct in $d_s$. Pairing of two conjuncts is possible under these conditions: 
\begin{itemize}
  \item The conjunct that belongs to $d_s$ is labeled as unused.
  \item Both conjuncts are of the same type, meaning that either both are Fin or both are Inf.
\end{itemize}

\begin{enumerate}[a)]
  \item If such pairing of conjuncts exists, then we can define injective function $\varphi_k (T_k) = T_i$, \footnote{Function $\varphi_k$ maps acceptance sets of $d_k$ to acceptance sets of $d_s$.} where $T_k$ is an acceptance set of a conjunct in $d_k$, and $T_i$ is the corresponding acceptance set of the conjunct in $d_s$. Then label the paired conjunct of $d_s$ as used.
  \item If such pairing of conjuncts does not exist, then we add a new conjunct to $d_s$. Let the new conjunct be of the same type as the conjunct in $d_k$ that could not be paired. It is necessary to prevent changing the language when adding the new conjunct. The language is preserved if the new conjunct is satisfied by any run of $\mathcal{A}_s$ that has a suffix contained in the SCC corresponding to $Acc_s$. In other words, if its type is Fin, then let the new acceptance set $T_x$, where $x = n + 1$, be an empty set.\footnote{It is necessary to update the of number acceptance sets of $\mathcal{A}_s$ to reflect this change. Let $T_i, i \in \{1,2, \dots, n, n+1\}$ denote any acceptance set of $Acc_s$. Further references to $n$ denote the maximal number of the set.} If the type of the conjunct is Inf, then let $T_x$ be a set of all transitions of the SCC corresponding to $Acc_s$. Label the new conjunct as used.
\end{enumerate}
If there are multiple possible pairings for a conjunct in $d_k$, then we choose the conjunct of $d_s$ with the lowest acceptance set index. The process is complete when all conjuncts of $d_k$ are successfully paired. 

To give an example, consider $d_s = \{\text{Inf}(T_1)\}$, $d_k = \{\text{Inf}(T_2), \text{Inf}(T_3)\}$. First step is to mark Inf$(T_1)$ as unused. Then we attempt to find pairing for Inf$(T_2)$. The only possible pairing is with Inf$(T_1)$. Therefore, we define $\varphi_k(T_2) = T_1$ and label Inf$(T_1)$ as used. Inf$(T_3)$ cannot be paired with any element of $d_s$. It is necessary to add a new conjunct to $d_s$, resulting in $d_s = \{\text{Inf}(T_1), \text{Inf}(T_4)\}$, where $T_4$ is a set of all transition of the SCC. We can define $\varphi_k(T_3) = T_4$ and label Inf$(T_4)$ as used. All conjuncts in $d_k$ are paired, therefore the merging process of disjuncts $d_s$ and $d_k$ is complete.

Note that we never need to add any new disjuncts to $Acc_s$, because it is the formula with the maximal cardinality.

When the process of merging formulae is complete, we use $\varphi_k$ to rename the acceptance sets in the corresponding SCC. For example, $\varphi_k (T_2) = T_1$ denotes that in the SCC corresponding to $Acc_k$ the transitions that belonged to $T_2$ now belong to $T_1$.

\subsection{Resolving conflicts caused by dependencies}
\label{subsec:resolve_conflicts}
Before merging the formulae, it is necessary to check if any conflicts may occur during the process. Conflicts during merging are situations that, if unresolved, may lead to two distinct acceptance sets that appear in $Acc_k \in F$ being mapped by $\varphi_k$ to only one set in $Acc_s$. For example, consider $Acc_s = \{\{\text{Inf}(T_1), \text{Fin}(T_2)\}, \{(\text{Inf}(T_1)\}\}$, and $Acc_k = \{\{\text{Inf}(T_3)\}, \{\text{Inf}(T_4), \text{Fin}(T_5)\}\}$. In this case, if we define $\varphi_k (T_3) = T_1, \varphi_k(T_4) = T_1, \varphi_k (T_5) = T_2$, then $T_3$ and $T_4$ are both mapped to the same acceptance set, which may change the language. Consider that $T_4$ and $T_5$ contain all transitions of the SCC corresponding to $Acc_k$ and $T_3$ is an empty set. Consequently, no run of the automaton with a suffix contained in the SCC corresponding to $Acc_k$ is accepting. After renaming the acceptance sets in the SCC according to $\varphi_k$, all transitions belong to $T_1$ and all runs with a suffix contained within the SCC corresponding to $Acc_k$ are accepting. Therefore, the language is different.

Conflicts only may occur when $Acc_s$ contains two or more disjuncts that contain the same acceptance set. If $Acc_s$ does not contain such disjuncts, then we may proceed with merging the formulae. 
 
If we discover possible conflicts, then we simulate the merging process to determine if any sets are mapped incorrectly. Incorrect mapping occurs in the following situations:
\begin{enumerate}[a)]
  \item Two distinct acceptance sets of $Acc_k$ are mapped to one acceptance set of $Acc_s$.
  \item There exists a set $T_i$, that appears in $Acc_s$ at least twice, and an injective function is defined that maps $T_k$ of $Acc_k$ to $T_i$. No set is mapped to the other occurrence of $T_i$. \\
  For example, $Acc_s = \{\{\text{Inf}(T_1), \text{Inf}(T_2)\}, \{\text{Inf}(T_1), \text{Fin}(T_3)\}\}$ and $Acc_k = \{\{\text{Inf}(T_4), \text{Inf}(T_5)\}, \{\text{Fin}(T_6)\}\}$. In this case, we define $\varphi_k (T_4) = T_1, \varphi_k (T_5) = T_2, \varphi_k (T_6) = T_3$, however in the second disjunct of $Acc_s$ the conjunct Inf$(T_2)$ remains unused.
  \item There exists a set $T_i$, that appears in $Acc_s$ at least twice, and an injective function is defined that maps $T_k$ of $Acc_k$ to $T_i$. The other occurrence of set $T_i$ is in such disjunct of $Acc_s$, which is not paired with any disjunct of $Acc_k$. \\
  For example, $Acc_s = \{\{\text{Inf}(T_1), \text{Inf}(T_2)\}, \{\text{Inf}(T_1)\}$ and $Acc_k = \{\{\text{Inf}(T_4), \text{Inf}(T_5)\}\}$. Then we define $\varphi_k (T_4) = T_1, \varphi_k (T_5) = T_2$. Similarly to the previous case, the second Inf$(T_1)$ remains unused. 
\end{enumerate}

If any of the incorrect mappings listed above occur, we resolve them by replacing all additional occurrences of the same set with a new set. The new set has to contain the same transitions as the original set, to prevent changing the language. 

More formally, let $T_i$ denote an acceptance set that appears in $Acc_s$ as Inf$(T_i)$. If the following condition holds for some $k < l$
\begin{equation*}
  d_k, d_l \in Acc_s \wedge \text{Inf}(T_i) \in d_l \wedge \text{Inf}(T_i) \in d_k \wedge i \in \{1, 2, \dots, n\}
\end{equation*}
then we modify each disjunct $d_k$ as follows:
\begin{equation*}
  d_k \coloneqq (d_k \smallsetminus \{\text{Inf}(T_i)\}) \cup \{\text{Inf}(T_x)\}
\end{equation*}
where $T_x = T_i$ and $x = n + 1$. The algorithm is analogous for Fin$(T_i)$.

\section{Restoring equivalence with the original automaton}
\label{sec:restore_equiv}
$Acc_s$ is the acceptance condition formula of the whole automaton $\mathcal{A}_s$. Assume that, the process of SCC-based simplifications resulted in each SCC  having its own distinct formula and acceptance sets. Replacing such formula with $Acc_s$ may change the language. Therefore, it is necessary to modify $Acc_s$ to preserve the acceptance conditions in each SCC. 

The SCC that corresponds with $Acc_s$ does not require any modifications, because its acceptance condition formula was selected as the base for $Acc_s$.

To restore the equivalence with the original automaton in \emph{never accepting} SCCs, it is necessary to ensure that each disjunct of $Acc_s$ is evaluated as \emph{false} for any run of $\mathcal{A}_s$. Any disjunct containing Inf$(T_i)$, where $T_i$ is any acceptance set of $Acc_s$, already satisfies this requirement, because any acceptance set $T_i$ of $Acc_s$ does not contain any transitions of $\delta_{\mathcal{A'}}$. If there is a disjunct in $Acc_s$ that only contains Fin$(T_i)$ conjuncts, where $T_i$ is any acceptance set of $Acc_s$, then one of these acceptance sets has to be modified as follows:
\begin{equation*}
  T_i \coloneqq T_i \cup \delta_{\mathcal{A'}},
\end{equation*}
where $\delta_{\mathcal{A'}}$ is a set of all transitions that belong to the \emph{never accepting} SCC. Then any run of $\mathcal{A}_s$ that has a suffix contained within that SCC is not satisfied because at least one transition of $T_i$ is visited infinitely often; therefore, Fin$(T_i)$ is evaluated as \emph{false}.

For all \emph{always accepting} SCCs, we need to ensure that at least one disjunct of $Acc_s$ is \emph{true} for any run of $\mathcal{A}_s$ that is contained within such SCC. If there is a disjunct in $Acc_s$ that only contains Fin$(T_i)$, where $T_i$ is any acceptance set of $Acc_s$, then the requirement is satisfied, because any acceptance set $T_i$ of $Acc_s$ does not contain any transitions of $\delta_{\mathcal{A'}}$. Otherwise, we choose a disjunct that contains the fewest Inf conjuncts and modify the acceptance sets of $Acc_s$ so that these conjuncts are \emph{true} for any run of $\mathcal{A}_s$ that is contained within the \emph{always accepting} SCC. All acceptance sets $T_i$ that appear in the selected disjunct in conjuncts Inf$(T_i)$ need to be modified as follows:
\begin{equation*}
  T_i \coloneqq T_i \cup \delta_{\mathcal{A'}},
\end{equation*}
where $\delta_{\mathcal{A'}}$ is a set of all transitions that belong to the \emph{always accepting} SCC. Then any run of $\mathcal{A}_s$ that is contained within that SCC is evaluated as \emph{true}, because for each acceptance set $T_i$, that appears in the disjunct as Inf$(T_i)$, at least one transition is visited infinitely often.

In \emph{maybe accepting} SCCs, we need to perform the following actions to restore equivalence with $\mathcal{A}$. Each disjunct $d_s$ of $Acc_s$ needs to be labeled as either \emph{satisfiable} or \emph{not satisfiable}.

Let $T_S$ be the set of acceptance sets that appear in $d_s$. If $\varphi_k$ maps any acceptance set of $Acc_k$ to any acceptance set in $T_S$, then $d_s$ is \emph{satisfiable}. If $\varphi_k$ does not map any acceptance set of $Acc_k$ to any acceptance set in $T_S$, then $d_s$ is \emph{not satisfiable}.

\emph{Satisfiable} disjuncts may contain conjuncts with acceptance sets, that are not present in $Acc_k$. Any such conjunct needs to be evaluated as \emph{true} for any run of $\mathcal{A}_s$. Therefore, the acceptance set $T_i$ of such conjunct is modified as follows:
\begin{equation*}
  T_i \coloneqq T_i \cup \delta_{\mathcal{A'}},
\end{equation*}
where $\delta_{\mathcal{A'}}$ is a set of all transitions that belong to the \emph{maybe accepting} SCC. 

Each disjunct, labeled as \emph{not satisfiable}, needs to be evaluated as \emph{false} for any run of $\mathcal{A}_s$. All disjuncts that contain at least one Inf$(T_i)$ already meet this requirement because any acceptance set $T_i$ of $Acc_s$ does not contain any transitions of $\delta_{\mathcal{A'}}$. All \emph{not satisfiable} disjuncts of $Acc_s$ that only contain Fin$(T_i)$ conjuncts need to be modified as follows:
\begin{equation*}
  T_i \coloneqq T_i \cup \delta_{\mathcal{A'}},
\end{equation*}
where $\delta_{\mathcal{A'}}$ is a set of all transitions that belong to the \emph{maybe accepting} SCC. 

For example, let $Acc_s = \{\{\text{Fin}(T_1), \text{Inf}(T_2)\}, \{\text{Fin}(T_3)\}\}, Acc_k = \{\{\text{Fin}(T_4)\}\}$ and $\varphi_k (T_4) = T_1$. Then the first disjunct of $Acc_s$ is \emph{satisfiable} and the second is \emph{not satisfiable}. It is necessary to modify acceptance sets $T_2 \coloneqq T_2 \cup \delta_{\mathcal{A'}}$ and $T_3 \coloneqq T_3 \cup \delta_{\mathcal{A'}}$.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \node[flabel] (pigfq) at (3.5, 3) {(Fin\accsquaremag $\ \vee\ $ Inf\accmarkor) $\ \wedge\ $ (Fin\accsquareblue $\ \vee\ $ Inf\accmarkred) $\ \wedge\ $ (Inf\accmarkgr $\ \wedge\ $ Inf\accmarkpink $\ \wedge\ $ Inf\accmarkyell)};
      \node[state, initial]   (0) at (0,0) {0};
      \node[state]            (1) at (3.5,-3.5) {1};
      \node[state]            (2) at (3.5,0) {2};
      \node[state]            (3) at (7,-3.5) {3};
      \node[state]            (4) at (7,0) {4};

      \path[->, very thick]               
              (0) edge[loop above]  node[above] {$a\overline{b}c$} node[accset, collacc2] {} (0) 
              (0) edge[right]  node[above] {$\overline{a}b\overline{c}$} node[accsquare, collacc1, pos=0.10] {} node[accset, collacc3, pos=0.30] {} node[accset, collacc4, pos=0.50] {} node[accset, collacc5, pos=0.70] {} (2)
              (0) edge[bend left]  node[below left] {$\overline{a}b\overline{c}$} (1)
              (0) edge[bend left]  node[above] {$a\overline{b}\overline{c}$} node[accset, collacc2, pos=0.35] {} node[accset, collacc3, pos=0.45] {} node[accset, collacc4, pos=0.55] {} node[accset, collacc6, pos=0.65] {} (4)
              (1) edge[bend left]  node[below left] {$\overline{a}bc$} node[accset, collacc3, pos=0.45] {} node[accset, collacc6, pos=0.55] {} (0)
              (2) edge[]  node[right] {$\overline{a}\overline{b}c$} node[accset, collacc2, pos=0.40] {} node[accset, collacc5, pos=0.60] {} (1)
              (1) edge[bend left]  node[above] {$abc$} node[accset, collacc6] {} (3)
              (3) edge[bend left]  node[below] {$\overline{a}bc$} node[accsquare, collacc1] {} (1)
              (3) edge[]    node[right] {$abc$} node[accsquare, collacc0, pos=0.40] {} node[accset, collacc2, pos=0.60] {} (4)
              (1) edge[]  node[above left] {$abc$} node[accset, collacc2] {} (4)
              (2) edge[]    node[above] {$ab\overline{c}$} node[accset, collacc3, pos=0.40] {} node[accset, collacc4, pos=0.60] {} (4);              
  \end{tikzpicture}
  \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
    \node[flabel] (pigfq) at (3.5, 3) {Inf\accmarkblue $\ \wedge\ $ Inf\accmarkmag $\ \wedge\ $ Inf\accmarkor};
    \node[state, initial]   (0) at (0,0) {0};
    \node[state]            (1) at (3.5,-3.5) {1};
    \node[state]            (2) at (3.5,0) {2};
    \node[state]            (3) at (7,-3.5) {3};
    \node[state]            (4) at (7,0) {4};

    \path[->, very thick]               
            (0) edge[loop above]  node[above] {$a\overline{b}c$} node[accset, collacc0] {} (0) 
            (0) edge[right]  node[above] {$\overline{a}b\overline{c}$} node[accsquare, collacc1] {} (2)
            (0) edge[bend left]  node[below left] {$\overline{a}b\overline{c}$} (1)
            (0) edge[bend left]  node[above] {$a\overline{b}\overline{c}$} (4)
            (1) edge[bend left]  node[below left] {$\overline{a}bc$} node[accset, collacc2] {} (0)
            (2) edge[]  node[right] {$\overline{a}\overline{b}c$} node[accset, collacc0] {} (1)
            (1) edge[bend left]  node[above] {$abc$} node[accset, collacc2] {} (3)
            (3) edge[bend left]  node[below] {$\overline{a}bc$} (1)
            (3) edge[]    node[right] {$abc$} (4)
            (1) edge[]    node[above left] {$abc$} (4)
            (2) edge[]    node[above] {$ab\overline{c}$} (4);              
\end{tikzpicture}
  \caption{TELA before (above) and after (below) using the proposed algorithm for acceptance formula simplification.}
  \label{fig:big_example}
\end{figure}

\chapter{Implementation}
TELAtko is the experimental implementation of the method proposed in Chapter \ref{chap:simpl_tela}. It is a command-line tool written in Python.

TELATtko uses SPOT library \cite{spot} for representing and modifying automata. SPOT functions for acceptance formulae modifications are limited; therefore, TELAtko includes implementation of data structures that represent acceptance formulae and acceptance sets. 

The implementation of acceptance formulae merging uses the \texttt{linear\_sum\_assignment} function from SciPy library \cite{scipy} to solve the assignment problem. 

The tool also uses the following Python libraries: \texttt{enum}, \texttt{argparse}, \texttt{sys}.

Table \ref{tab:arguments} shows the arguments and their descriptions. If no output file is given, the automaton is printed to \texttt{stdout}. The output automaton is in \textit{Hanoi} $\omega$\textit{-automata} (HOA) format \cite{hoa}.

\begin{table}[h]
  \begin{tabularx}{\textwidth}{lXXX}
    \toprule
    Argument & Description \\
    \midrule
    -F & Path to the file containing the input automata. Obligatory argument. \\
    -O & Path to the output file. \\
    -h & Prints the possible arguments and their descriptions. \\    
    \bottomrule
  \end{tabularx}
  \caption{Arguments of TELAtko}
  \label{tab:arguments}
\end{table}

\chapter{Experimental Evaluation}
This chapter contains the results of the experimental evaluation of TELAtko. All experiments were performed on a laptop with Intel Core i5-7200U (2.50GHz) processor and 8GB RAM. 

We generated 4000 LTL \cite{ltl} formulae using \textbf{randltl} tool (version 2.8.4) \cite{randltl}. The formulae were then translated using \textbf{ltl2dgra}, a translator tool included in Rabinizer4 \cite{rabinizer}. We filtered out automata with fewer than 3 acceptance sets and fewer that 3 SCCs. The remaining 673 automata are referred to as \emph{set1}.

We generated 10000 LTL formulae using the \textbf{randltl} tool. The formulae were then translated using LTL3TELA (version 2.1.0) \cite{ltl3tela}. We filtered out automata with less than 2 acceptance sets and less than 3 SCCs. The remaining 399 automata are referred to as \emph{set2}.

Both sets were used to run the following experiments. First, we used \textbf{autfilt} (version 2.8.4) \cite{spot} with \emph{simplify-acceptance} transformation option. The transformed automata were then processed by TELAtko. Finally, we used \textbf{autfilt} with \emph{simplify-acceptance} again on the automata processed by TELAtko. All statistics were generated using \textbf{autcross} (version 2.8.4) \cite{spot}.

Table \ref{tab:rabinizer4} shows the results of the experiments with set1. TELAtko significantly reduced the length of acceptance formulae, but the number of acceptance sets remained the same. Using \textbf{autfilt} after TELAtko lead to an increase in the length of acceptance formulae, but the number of acceptance sets in the transformed automata was reduced.

\begin{table}[h]
  \begin{tabularx}{\textwidth}{lXXX}
    \toprule
    Tool & Number of states & Number of acceptance sets & Length of acceptance formula  \\
    \midrule
    Autfilt & 6041 & 1888 & 1909 \\
    TELAtko & 6041 & 1363 & 1372 \\
    Autfilt & 5877 & 1367 & 1376 \\    
    \bottomrule
  \end{tabularx}
  \caption{Overall results of \textbf{autfilt} and our tool used on automata translated by Rabinizer4.}
  \label{tab:rabinizer4}
\end{table}

Table \ref{tab:ltl3tela} shows the results of experiments run with set2. TELAtko did not remove any acceptance sets, but reduced the length of acceptance formulae. The second use of \textbf{autfilt} resulted in a decrease in both number of acceptance sets and length of acceptance formulae.

\begin{table}[h]
  \begin{tabularx}{\textwidth}{lXXX}
    \toprule
    Tool & Number of states & Number of acceptance sets & Length of acceptance formula  \\
    \midrule
    Autfilt & 2658 & 926 & 929 \\
    TELAtko & 2658 & 822 & 830 \\
    Autfilt & 2658 & 820 & 828 \\    
    \bottomrule
  \end{tabularx}
  \caption{Overall results of the experiments using set2.}
  \label{tab:ltl3tela}
\end{table}

\begin{figure}[h!]
  \centering
    \begin{tikzpicture}
      \input{scplot_at_marks.tex}
    \end{tikzpicture}
  \caption{Plot showing the numbers of acceptance sets of automata transformed with \textbf{autfilt} compared to \textbf{autfilt} + TELAtko + \textbf{autfilt}. Cross marks denote automata from set1, circle marks denote automata from set2.}
  \label{fig:scplot_marks}
\end{figure}

\begin{figure}[h]
  \centering
    \begin{tikzpicture}
      \input{scplot_at_flen.tex}
    \end{tikzpicture}
  \caption{Plot showing the length of acceptance formulae of automata transformed with \textbf{autfilt} compared to \textbf{autfilt} + TELAtko + \textbf{autfilt}. Cross marks denote automata from set1, circle marks denote automata from set2.}
  \label{fig:scplot_formula_len}
\end{figure}

\chapter{Conclusion}
In this thesis, we proposed SCC-based simplifications of acceptance condition formulae for TELA. The proposed method includes simplification techniques and methods for formulae merging and restoring equivalence with the input automaton.

This thesis includes an experimental implementation of the proposed method in the form of a command-line tool. During the development phase, we discovered and reported a bug in SPOT library, which caused some simplified automata to be falsely labeled as incorrect (i.e., not equivalent to the input automata) during testing.

The experimental evaluation shows that the tool frequently reduces the length of acceptance formulae and, when combined with \textbf{autfilt}, results in a reduction of the number of acceptance sets of automata.

For some automata, using a different formulae merging method may lead to better results, if the method removes dependencies without adding new acceptance sets, or completely avoids creating dependencies. 

\printbibliography[heading=bibintoc]

\appendix
\chapter{An appendix}
\section{Running TELAtko}
\begin{itemize}
  \item Install SPOT\footnote{\url{https://spot.lrde.epita.fr/install.html}} v.2.8+ and SciPy\footnote{\url{https://www.scipy.org/install.html}} into the \texttt{PATH} of your system.
  \item Go to the directory with TELAtko. Examples of running TELAtko: "./TELAtko -F myautomata.hoa", "./TELAtko -F myautomata.hoa -O result.hoa"
\end{itemize}
\section{Contents of thesis.zip}
I have submitted the following attachments:
\begin{itemize}
  \item \texttt{TELAtko.py}, a command-line tool under GNU General Public License
  \item \texttt{set1.hoa, set2.hoa} files with automata used for the experiments
  \item \texttt{set1\_autfilt1.csv, set1\_telatko.csv, set1\_autfilt2.csv, set2\_autfilt1.csv, set2\_telatko.csv, set2\_autfilt2.csv} files with the results of the experiments
\end{itemize}
\end{document}
