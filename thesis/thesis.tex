%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital, %% This option enables the default options for the
           %% digital version of a document. Replace with `printed`
           %% to enable the default options for the printed version
           %% of a document.
  twoside, %% This option enables double-sided typesetting. Use at
           %% least 120 g/m² paper to prevent show-through. Replace
           %% with `oneside` to use one-sided typesetting; use only
           %% if you don’t have access to a double-sided printer,
           %% or if one-sided typesetting is a formal requirement
           %% at your faculty.
  table,   %% This option causes the coloring of tables. Replace
           %% with `notable` to restore plain LaTeX tables.
  lof,     %% This option prints the List of Figures. Replace with
           %% `nolof` to hide the List of Figures.
  lot,     %% This option prints the List of Tables. Replace with
           %% `nolot` to hide the List of Tables.
  %% More options are listed in the user guide at
  %% <http://mirrors.ctan.org/macros/latex/contrib/fithesis/guide/mu/fi.pdf>.
]{fithesis3}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{russian} ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% For non-Latin scripts, it may be necessary to load additional
%% fonts:
\usepackage{paratype}
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date          = \the\year/\the\month/\the\day,
    university    = mu,
    faculty       = fi,
    type          = bc,
    author        = {Tereza Šťastná},
    gender        = f,
    advisor       = {doc. RNDr. Jan Strejček, Ph.D.},
    title         = {Simplification\\ of Acceptance Condition\\ of Emerson-Lei Automata},
    TeXtitle      = {Simplification\\ of Acceptance Condition\\ of Emerson-Lei Automata},
    keywords      = {keyword1, keyword2, ...},
    TeXkeywords   = {TELA, TGBA, $\omega$-automata, SPOT, SCC-based simplifications},
    abstract      = {%
      This is the abstract of my thesis, which can

      span multiple paragraphs.
    },
    thanks        = {%
      These are the acknowledgements for my thesis, which can

      span multiple paragraphs.
    },
    bib           = bibliography.bib,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} 
\usepackage{amsmath}  
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{url}      
\usepackage{markdown} 
\usepackage{tabularx} 
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{listings} 
\usepackage{tikz}
\usetikzlibrary{automata,nicearrows,bending,myautomata}
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
%% The following code fixes the rendering of BibLaTeX ISO 690
%% references in old TeX Live (such as the one at Overleaf).
\thesisload
\makeatletter
\def\thesis@biblatexiso@fix@package{iso-numeric.bbx}
\def\thesis@biblatexiso@fix@end{\relax}
\newif\ifthesis@biblatexiso@fix@
\thesis@biblatexiso@fix@false
\def\thesis@biblatexiso@fix@next#1,{%
  \def\thesis@biblatexiso@fix@current{#1}%
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@package
    \thesis@biblatexiso@fix@true
  \fi
  \ifx\thesis@biblatexiso@fix@current\thesis@biblatexiso@fix@end
    \expandafter
    \@gobble
  \fi
  \thesis@biblatexiso@fix@next
}
\expandafter\expandafter\expandafter\thesis@biblatexiso@fix@next\@filelist,\relax,
\ifthesis@biblatexiso@fix@
  \defbibenvironment{bibliography}
    {\list%
       {\MethodFormat}%
       {\setlength{\labelwidth}{\labelnumberwidth}%
        \setlength{\leftmargin}{\labelwidth}%
        \setlength{\labelsep}{\biblabelsep}%
        \addtolength{\leftmargin}{\labelsep}%
        \setlength{\itemsep}{\bibitemsep}%
        \setlength{\parsep}{\bibparsep}}%
        \renewcommand*{\makelabel}[1]{\hss##1}
        }%
    {\endlist}%
  {\item}%
\fi
\makeatother
\begin{document}
% Tikz styles 
\tikzset{
  collacc0/.style={fill=blue!50!cyan},
  collacc1/.style={fill=magenta},
  collacc2/.style={fill=orange!90!black},
  collacc3/.style={fill=green!70!black},
  collacc4/.style={fill=blue!50!black},
}

\newcommand{\accmarkblue}{\begin{tikzpicture} \node[accset, collacc0] {}; \end{tikzpicture}}
\newcommand{\accmarkmag}{\begin{tikzpicture} \node[accset, collacc1] {}; \end{tikzpicture}}
\newcommand{\accmarkor}{\begin{tikzpicture} \node[accset, collacc2] {}; \end{tikzpicture}}
\newcommand{\accsquare}{\begin{tikzpicture} \node[accset, collacc0] {}; \end{tikzpicture}}

\chapter{Introduction}
Our society has become heavily reliant on computer systems in order to function. Unexpected behavior of software often results merely in minor inconvenience. However is some cases, it might pose a threat to human safety. Therefore it is crucial to have the ability to verify if the properties of software in question behave as intended. 

One such verification method is model-checking. The basic idea of this method is using finite state automata to accurately describe the current state of the given program at any time during its execution. The states of the automaton represent the current state of the program, and the transitions between them describe how specific events shift the state of the program from one to another. To be able to describe programs that should never terminate, we use $\omega$-automata -- finite automata on infinite words. During the process of model-checking, a product of two automata is created. It is desirable for the product to be as small as possible, which can be achieved by applying reduction methods to the original automata. 

For some reduction techniques, such as simulation-based reduction and degeneralization, it is beneficial to minimize the number of acceptance sets in the automaton. Babiak et al. \cite{spin2013} introduce the SCC-based simplifications of acceptance conditions. It is a method that proposes how to reduce the number of acceptance sets in Transition-based Büchi automata (TGBA). For each strongly connected component, it evaluates the relation between acceptance sets and removes the useless ones. 

The goal of this thesis is to propose and implement an analogous simplification method for transition-based Emerson-Lei automata (TELA). This method includes techniques to identify useless acceptance sets and modifications to the acceptance condition formula. During this process, we obtain separate acceptance condition formulas for each accepting SCC. Therefore, the presented method also describes how to merge these formulas into one. Finally, it describes the necessary modifications which ensure that the simplified automaton and the original automaton are equivalent. The desired outcome is to reduce the number of unique acceptance sets in the automaton. 

This thesis is structured into several chapters. Chapter two contains the basic definitions used throughout the thesis. Chapter three summarizes the ideas of the SCC-based simplification method for TGBA \cite{spin2013}. Chapter four presents the SCC-based simplification of TELA. Chapter five discusses the implementation specifics of this method. Chapter six presents the results of experimental evaluation of the implemented tool. Chapter seven contains the conclusion. TODO: add more details

\chapter{Basic definitions}
\label{chap:basic_definitions}
TODO: popis obsahu kapitoly

\section{Transition-based Emerson-Lei automaton (TELA)} 
\label{sec:tela}
A transition-based Emerson-Lei automaton, as defined in \cite{bloemen2017}, is a tuple $\mathcal{A} = (\Sigma, Q, q_0, \delta, Acc)$, where
\begin{itemize}
  \item $\Sigma$ is an alphabet,
  \item $Q$ is a finite set of states,
  \item $q_0 \in Q$ is the initial state,
  \item $\delta \subseteq Q \times \Sigma \times Q$ is a transition relation,
  \item $Acc$ is the acceptance condition formula, defined as a positive Boolean function over terms of the form Fin$(T_i)$ or Inf$(T_i)$ for any acceptance set $T_i \subseteq \delta, T_i \in \{1, 2, \dots, n\}$. 
\end{itemize}

In figures, an acceptance set is represented by acceptance marks (for example \accmarkblue) placed on the transitions which belong to that set.

For a transition $t = (t^s, t^l, t^d) \in \delta$, $t^s$ denotes its source, $t^l$ its label and $t^d$ its destination.

$\rho \in \delta^\omega$ where $\rho(0)^s = q_0 \wedge \forall j \geq 0 \colon \rho(j)^d = \rho(j + 1)^s$ is a run of $\mathcal{A}$ over $\Sigma^\omega$.

The acceptance of a run $\rho$ is defined by evaluating $Acc$ over $\rho$ where
\begin{itemize}
  \item Fin$(T_i)$ is true if all the transitions in $T_i$ occur finitely often, 
  \item Inf$(T_i)$ is true if some transition in $T_i$ occurs infinitely often.
\end{itemize}

\section{Transition-based generalized Büchi automaton (TGBA)}
\label{sec:tgba}
Transition-based Generalized Büchi Automaton, as defined in \cite{bloemen2017}, is a TELA $\mathcal{A'} = (\Sigma, Q, q_0, \delta, Acc)$ where 
\begin{equation*}
  Acc = \text{Inf}(T_1) \wedge \text{Inf}(T_2) \wedge \dots \wedge \text{Inf}(T_n)
\end{equation*} 
for some $n$. A run of TGBA over an infinite word is accepting if some transition in $T(i)$ occurs infinitely often for all $i \in \{1, 2, \dots, n\}$. 

\chapter{SCC-based simplification of acceptance conditions of TGBA} 
\label{chap:tgba_simpl}
This chapter summarizes the SCC-based simplifications of TGBA proposed in TODO: \cite{spin2013}.

Let $\mathcal{A'}$ be a TGBA with $n$ acceptance sets: 
\begin{equation*}
  Acc = \text{Inf}(T_1) \wedge \text{Inf}(T_2) \wedge \dots \wedge \text{Inf}(T_n).
\end{equation*}
Let $m$ be the number or accepting SCCs in $\mathcal{A'}$ and $A_\delta = \{A_1, \dots, A_m\}$ be the set of all transitions induced by the accepting SCCs of $\mathcal{A'}$. 
Any accepting run of $\mathcal{A'}$ will be contained in some accepting SCC. Therefore any transitions that are not in $A_\delta$ can be removed without changing the language accepted by $A'$. We can modify the acceptance sets of $\mathcal{A'}$ as follows: 
\begin{equation*}
  Acc = \text{Inf}(T_1 \cap A_\delta) \wedge \text{Inf}(T_2 \cap A_\delta) \wedge \dots \wedge \text{Inf}(T_n \cap A_\delta).
\end{equation*}
If $Acc$ contains such sets that $T_i \subseteq T_j$ and $i \neq j$, we can remove $T_j$, because any run that visits $T_i$ infinitely often also visits $T_j$ infinitely often. Therefore, removing $T_j$ will not change the language.
For each accepting SCC we can define a set of indices of useless acceptance sets 
\begin{equation*}
  \begin{aligned}
    U_k = &\{ j \in \{1, 2, \dots, n\} \mid \exists i \in \{1, 2, \dots, n\}, \\
    &(T_i \cap A_k \subsetneq T_j \cap A_k) \vee (T_i \cap A_k = T_j \cap A_k \wedge j > i)\}.
  \end{aligned}
\end{equation*}
If the two sets $T_i$ and $T_j$ are equal, then, by this definition, only one of their indices belongs to $U_k$, ensuring that one of the sets will be preserved. The set of indices of needed acceptance sets for any accepting SCC is $N_k = \{1, 2, \dots, n\} \smallsetminus U_k$. 

This may result in each SCC having a different number of acceptance sets, however the automaton as a whole can only have one set of acceptance sets. The number of acceptance sets needed in the simplified automaton is $n' = max_{k \in \{1, 2, \dots, n\}} |N_k|$. Let $N'_k$ be a copy of $N_k$. By adding $n' - |N_k|$ indices from $U_k$ to $N'_k$, we ensure that $|N'_k| = n'$ for each accepting SCC. Let $\alpha_k \colon \{1, \dots, n'\} \to N'_k$ be any bijection. Now we can define the new acceptance sets of the simplified automaton as
\begin{equation*}
  T'_i = \underset{k \in \{1, \dots, m\}}\bigcup (T_{\alpha_k(i)} \cap A_k)
\end{equation*}
in acceptance condition formula $Acc = \text{Inf}(T'_1) \wedge \text{Inf}(T'_2) \wedge \dots \wedge \text{Inf}(T'_{n'})$.

\begin{figure}[h]
  \begin{center}
    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \tikzstyle{every state}=[very thick]
      \node[state, initial above]   (0) at (0,0) {0};
      \node[state]            (1) at (-3, 0) {1};
      \node[state]            (2) at (3, 0) {2};

      \path[->, very thick]
              (0) edge[bend right]  node [above] {\texttt{tt}} (1) 
                  edge[bend left]   node [above] {\texttt{tt}} (2) 
              (1) edge[loop above]  node[above] {$ab$} node[accset, collacc1, pos=0.40] {} node[accset, collacc0, pos=0.15] {} node[accset, collacc2, pos=0.75] {} (1) 
                  edge[loop left]   node[left] {$a\overline{b}$} node[accset, collacc1] {} node[accset, collacc2, pos=0.15] {} (1) 
                  edge[loop right]  node[right] {$\overline{a}\overline{b}$} node[accset, collacc1] {} (1) 
                  edge[loop below]  node[below] {$\overline{a}b$} node[accset, collacc1] {} node[accset, collacc0, pos=0.15] {} (1) 
              (2) edge[loop above]  node[above] {$c$} node[accset, collacc1, pos=0.40] {} node[accset, collacc0, pos=0.15] {} node[accset, collacc2, pos=0.75] {} (2) 
                  edge[loop below]  node[below] {$\overline{c}$} node[accset, collacc0] {} node[accset, collacc2, pos=0.15] {} (2);    
    \end{tikzpicture}
    \caption{TGBA with three acceptance sets}
    \label{fig:tgba}
  \end{center}
\end{figure}

In Figure \ref{fig:tgba} there is a TGBA with two accepting SCCs. Let $S_1$ be the SCC comprised of state 1 and $S_2$ be the SCC comprised of state 2. The set of useless acceptance sets for $S_1$ is $U_1 = \{\accmarkmag\}$, because $\accmarkblue \subseteq \accmarkmag$ (and also $\accmarkor \subseteq \accmarkmag$). For $S_2$ it is $U_2 = \{\accmarkblue, \accmarkor\}$, because $\accmarkmag \subseteq \accmarkblue$ and $\accmarkmag \subseteq \accmarkor$.

The sets of needed acceptance sets for $S_1, S_2$ are $N_1 = \{\accmarkblue, \accmarkor\}$, $N_2 = \{\accmarkmag\}$ respectively. The number of needed acceptance sets for the whole automaton is $n' = 2$. We can define $N'_1 = N_1, N'_2 = N_2 \cup \{\accmarkor\}, \alpha_1 (\accmarkor) = \accmarkor, \alpha_1 (\accmarkblue) = \accmarkblue, \alpha_2 (\accmarkor) = \accmarkor, \alpha_2 (\accmarkblue) = \accmarkmag$. The result is the TGBA in Figure \ref{fig:simpl_tgba}.

\begin{figure}[h]
    \begin{center}
    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,very thick,initial text={}]
      \tikzstyle{every state}=[very thick]
      \node[state, initial above]   (0) at (0,0) {0};
      \node[state]            (1) at (-3, 0) {1};
      \node[state]            (2) at (3, 0) {2};

      \path[->, very thick]
              (0) edge[bend right]  node [above] {\texttt{tt}} (1) 
                  edge[bend left]   node [above] {\texttt{tt}} (2) 
              (1) edge[loop above]  node[above] {$ab$} node[accset, collacc0, pos=0.15] {} node[accset, collacc2] {} (1) 
                  edge[loop left]   node[left] {$a\overline{b}$} node[accset, collacc2] {} (1) 
                  edge[loop right]  node[right] {$\overline{a}\overline{b}$} (1) 
                  edge[loop below]  node[below] {$\overline{a}b$} node[accset, collacc0] {} (1) 
              (2) edge[loop above]  node[above] {$c$} node[accset, collacc0, pos=0.15] {} node[accset, collacc2] {} (2) 
                  edge[loop below]  node[below] {$\overline{c}$} node[accset, collacc2] {} (2);    
    \end{tikzpicture}
    \caption{TGBA from Figure \ref{fig:tgba} after SCC-based acceptance simplification}
    \label{fig:simpl_tgba}
  \end{center}
\end{figure}


\chapter{SCC-based simplification of acceptance conditions of TELA}
\label{chap:simpl_tela}
This chapter presents the proposed simplification methods for TELA. The first section describes the process of analyzing an SCC. The second section proposes several techniques that may remove useless acceptance sets in the sub-automaton induced by SCCs selected based on the analysis in Section \ref{sec:init_analysis}. The third section presents the method used for merging the separate acceptance condition formulae of all SCCs into one. The resulting formula is the acceptance condition of the simplified automaton. This section also covers how to identify and resolve possible conflicts caused by dependencies between disjuncts in formulae. Section four describes the necessary modifications to the simplified automaton that ensure its equivalence with the input automaton. 

In this chapter, let the input TELA have at least one acceptance set. Let the acceptance condition formula of the TELA be in disjunctive normal form (DNF). When referring to the whole automaton, we use notation $\mathcal{A}$. $Acc$ denotes the acceptance condition formula of the whole automaton. $\mathcal{A'}$ refers to a sub-automaton induced by an SCC of the original automaton, and $Acc$ refers to the acceptance condition formula of $\mathcal{A'}$.

Because the formula is in DNF, we can represent it as $Acc = \{d_1, d_2, \dots, d_m\}$ , where each $d_k$ is a disjunct. Further, each such disjunct $d_k$ is represented as a set of conjuncts. For example, formula $Acc_e = (\text{Inf}(T_1) \wedge \text{Fin}(T_2)) \vee (\text{Inf}(T_3))$ is represented by $Acc_e = \{d_1, d_2\}$, where $d_1 = \{\text{Inf}(T_1), \text{Fin}(T_2)\}, d_2 = \{\text{Inf}(T_3)\}$. 

Let $S$ be the set of states of an SCC. Then $A = \{t \mid t^s \in S \wedge t^d \in S\}$ is the set of all transitions of that SCC. In other words, $A$ is a set of all transitions in $\mathcal{A'}$.

\section{Initial analysis of SCCs}
\label{sec:init_analysis}
Before applying any simplification techniques, we first analyze each SCC and assign it one of the following attributes: \emph{always accepting}, \emph{never accepting}, \emph{maybe accepting}. The purpose of this classification is to help determine the necessary modifications when restoring equivalence with the original automaton as described in Section \ref{sec:restore_equiv}. 

Let $Acc'$ be a copy of $Acc$.

Let $T_{all} = \{i \mid i \in \{1, 2, \dots, n\} \wedge \forall t \in A \colon t \in T_i \}$ be the set of indices of acceptance sets that contain all transitions of the SCC.

Let $T_{any} = \{i \mid i \in \{1, 2, \dots, n\} \wedge \exists t \in A \colon t \in T_i \}$ be the set of indices of acceptance sets that contain at least one transition of the SCC.

Let $T_i, i \in \{1, 2, \dots, n\}$ be an acceptance set of $\mathcal{A}$. Now we perform the following substitutions for each disjunct $d_k$ in the $Acc'$.
\begin{itemize}
  \item If $i \in T_{all}$ then we substitute \emph{true} for Inf$(T_i)$.
  \item If $i \in T_{all}$ then we substitute \emph{false} for Fin$(T_i)$.
  \item If $i \notin T_{any}$ then we substitute \emph{false} for Inf$(T_i)$.
  \item If $i \notin T_{any}$ then we substitute \emph{true} for Fin$(T_i)$.
\end{itemize}

Any disjunct in the $Acc'$ that only contains \emph{true} is evaluated as \emph{true}. Any disjunct in the $Acc'$ that contains at least one \emph{false} is evaluated as \emph{false}. 

If any disjunct in the $Acc'$ is \emph{true}, then the SCC is \emph{always accepting}. If all disjuncts in the $Acc'$ are \emph{false}, then the SCC is \emph{never accepting}. If neither of the above conditions applies, then the SCC is \emph{maybe accepting}.

\section{SCC simplifications}
This section presents the simplification methods that can be applied to all SCCs, which are \emph{maybe accepting}. Using these methods on \emph{always accepting} or \emph{never accepting} SCCs is not necessary because the acceptance formula of such SCCs can be replaced with \emph{true} or \emph{false} respectively. 

Unlike TGBA, TELA have complex acceptance condition formulae. Therefore, to identify which acceptance sets are useless, we need to consider not only the relation between the transitions in these sets but also the specifics of their occurrence in the acceptance condition formula. 

For example, consider acceptance sets $T_1, T_2, T_3$ and $T_1 \subseteq T_2$ and $Acc_a = \text{Inf}(T_1) \wedge \text{Inf}(T_2)$. In this case, we can apply the simplifications described in Chapter \ref{chap:tgba_simpl} and remove $T_2$, because the form of $Acc_a$ is identical with the form of TGBA formula. However, in $Acc_b = \text{Inf}(T_1) \vee (\text{Inf}(T_2) \wedge \text{Fin}(T_3))$ simply removing $T_2$ could change the language. This example demonstrates that for SCC-based TELA simplifications, it is necessary to carefully define the requirements about the form of the acceptance condition formula.

\subsection{Acceptance condition formula modifications}
In the previous section, we proposed several substitutions used to analyze the SCCs. By using similar approach, we can remove useless disjuncts from the $Acc$, and useless conjuncts from the remaining disjuncts.

Let $T_i$ be an acceptance set that only appears in $Acc'$ as Fin$(T_i)$. If all transitions of $\mathcal{A'}$ belong to $T_i$, then during a run of $\mathcal{A'}$ at least one transition of $T_i$ is visited infinitely often. Therefore Fin$(T_i)$ is always \emph{false} for any run of $\mathcal{A'}$. Any disjunct $d_k$ of $Acc'$ that contains Fin$(T_i)$ can be removed without changing the language.

%TODO: check from here
More formally, if the following conditions hold
\begin{itemize}
  \item $i \in \{1,2, \dots, n\}$,
  \item $k\in \{1,2, \dots, m\}$,
  \item $T_i = A$,
\end{itemize}
then we can define the set of useless disjuncts as
\begin{equation*}
  U = \{d_k \mid d_k \in Acc, Fin(T_i) \in d_k \}
\end{equation*}
and remove it from the $Acc'$:
\begin{equation*}
  Acc' = Acc' \smallsetminus U.
\end{equation*}

Let $T_i$ be an acceptance set that only appears in $Acc'$ as Inf$(T_i)$. If $T_i$ does not contain any transitions of $\mathcal{A'}$, then any disjunct $d_k$ in $Acc'$ that contains Inf$(T_i)$ can be removed. Removing $d_k$ does not change the language, because any run of $\mathcal{A'}$ does not visit any transitions that belong to $T_i$. 

Formally, if these conditions are met
\begin{itemize}
  \item $i \in \{1,2, \dots, n\}$,
  \item $k\in \{1,2, \dots, m\}$,
  \item $T_i \cap A = \emptyset$,
\end{itemize}
then 
\begin{equation*}
  U = \{d_k \mid d_k \in Acc, \text{Inf}(T_i) \in d_k \}
\end{equation*}
is the set of useless disjuncts that can be removed from $Acc'$:
\begin{equation*}
  Acc' = Acc' \smallsetminus U.
\end{equation*}

If an acceptance set $T_i$ contains all transitions of the SCC, then Inf$(T_i)$ is always evaluated as true. Therefore Inf$(T_i)$ can be removed from all disjuncts of $Acc'$ without changing the language. 
%TODO: finish

Similarly, Fin$(T_i)$ is always true if no transitions of the SCC belong to $T_i$. Therefore all such Fin$(T_i)$ can be removed from the $Acc'$.
%TODO: finish

This simplification can be applied if there are such disjuncts $d_k, d_l$ in the $Acc$ that $d_k \subseteq d_l$. In this case, it does not matter if any acceptance set $T_i \in d_k \cap d_l$ appear in the $Acc$ as Inf$(T_i)$ or Fin$(T_i)$. Disjunct $d_l$ can be removed from the $Acc$. This modification does not affect the Boolean value of the formula, because either $d_k$ is satisfied and the whole formula is evaluated as true regardless of $d_l$, or $d_k$ is not satisfied, in which case $d_l$ is also not satisfied. 

Formally, if these conditions are met:
\begin{itemize}
  \item $i \in \{1,2, \dots, n\}$,
  \item $k,l \in \{1,2, \dots, m\}$,
  \item $\exists d_k, d_l \in Acc \colon d_k \subseteq d_l $,
\end{itemize}
we may remove $d_l$ from $Acc$:
\begin{equation*}
  Acc = Acc \smallsetminus \{d_l\}.
\end{equation*}

\subsection{Inclusion-based simplifications}
%Inf & Inf
Let $T_1 \subseteq T_2$ be two distinct acceptance sets that appear in the acceptance condition formula only in terms Inf$(T_1)$ and Inf$(T_2)$. We can modify the simplifications from Chapter \ref{chap:tgba_simpl} to make them viable for TELA by adding a prerequisite that demands a specific form of the acceptance formula. The requirement is that for any disjunct in the formula, either both sets are present, or neither is present. If the required conditions are met, we may remove $T_2$ from the formula. 

More formally, if the following conditions hold
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\}$,
  \item $(T_i \subsetneq T_j \vee (T_i = T_j \wedge j > i))$,
  \item $\forall d_k \in Acc \colon (\text{Inf}(T_i) \in d_k \Leftrightarrow \text{Inf}(T_j) \in d_k)$,
\end{itemize}
then we can remove Inf$(T_j)$ from $Acc$: 
\begin{equation*}
  Acc = \{d_1 \smallsetminus \{\text{Inf}(T_j)\}, d_2 \smallsetminus \{\text{Inf}(T_j)\}, \dots, d_m \smallsetminus \{\text{Inf}(T_j)\}\}.
\end{equation*} 

%Fin & Fin
Let $T_1 \subseteq T_2$ be two distinct acceptance sets that only appear in the $Acc$ as Fin$(T_i)$ and Fin$(T_j)$. If each disjunct in $Acc$ either contains both Fin$(T_i)$ and Fin$(T_j)$ or contains neither of them, then Fin$(T_i)$ can be removed from the $Acc$.  Removing Fin$(T_i)$ does not change the language, because when transitions in $T_j$ are visited finitely often during a run of $\mathcal{A}$, then also transitions in $T_i$ are visited finitely often. 

Formally, if these conditions are met:
\begin{itemize}
  \item $i, j \in \{1,2, \dots, n\}$,
  \item $(T_i \subsetneq T_j) \vee (T_i = T_j \wedge T_i = T_j)$,
  \item $\forall d_k \in Acc \colon (\text{Fin}(T_i) \in d_k \Leftrightarrow \text{Fin}(T_j) \in d_k)$,
\end{itemize}
then Fin$(T_i)$ can be removed from the $Acc$:
\begin{equation*}
  Acc = \{d_1 \smallsetminus \{\text{Fin}(T_i)\}, d_2 \smallsetminus \{\text{Fin}(T_i)\}, \dots, d_m \smallsetminus \{\text{Fin}(T_i)\}\}.
\end{equation*}

%Inf & Fin
Let $T_1 \subseteq T_2$ be two distinct acceptance sets that only appear in the $Acc$ as Inf$(T_i)$ and Fin$(T_j)$. If there is such disjunct $d_k$ in the $Acc$, that it contains both Inf$(T_i)$ and Fin$(T_j)$, then $d_k$ can be removed from the $Acc$. Removing $d_k$ does not change the language, because any run of $\mathcal{A}$ that visits $T_j$ finitely often cannot visit any transition in $T_i$ infinitely often. Therefore $d_k$ is evaluated as false for any run of $\mathcal{A}$. 

If the following conditions hold
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\}$,
  \item $(T_i \subsetneq T_j \vee (T_i = T_j \wedge j > i))$,
  \item $F = \{d_k \mid d_k \in Acc \wedge \text{Inf}(T_i) \in d_k \wedge \text{Fin}(T_j) \in d_k \}$,
\end{itemize}
then the we can define $Acc$ without always-false disjuncts as:
\begin{equation*}
  Acc = Acc \smallsetminus F.
\end{equation*}

\subsection{Simplification of complementary acceptance sets}
Let $T_i$ and $T_j$ be two distinct acceptance sets that appear in the $Acc$ only as Fin$(T_i)$ and Inf$(T_j)$. Let $T_i$ and $T_j$ be complementary. If each $d_k$ from $Acc$ that contains Inf$(T_j)$ also contains Fin$(T_i)$, then we can remove Inf$(T_j)$ without changing the language. If a run of $\mathcal{A}$ is contained in the SCC and all transitions in $T_i$ are visited finitely often, then necessarily at least one transition in $T_j$ is visited infinitely often. Therefore keeping only the conjunct Fin$(T_i)$ in $d_k$ is sufficient. 

More formally, if these conditions are met:
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\} , i \neq j$,
  \item $\exists T_i, T_j \colon A \smallsetminus T_i = T_j$,
  \item $\forall d_k \in Acc \colon \text{Inf}(T_j) \in d_k \Rightarrow \text{Fin}(T_j) \in d_k$,
\end{itemize}
then Inf$(T_j)$ can be removed from $Acc$:
\begin{equation*}
  Acc = \{d_1 \smallsetminus \{\text{Inf}(T_j)\}, d_2 \smallsetminus \{\text{Inf}(T_j)\}, \dots, d_m \smallsetminus \{\text{Inf}(T_j)\} \}
\end{equation*}

\subsection{Combining Fin conjuncts}
If $\mathcal{A'}$ has such acceptance sets $T_i$ and $T_j, i \neq j$, that both sets only appear in the $Acc'$ as Fin$(T_i)$ and Fin$(T_j)$ and each disjunct of $Acc'$ either contains both or neither of them, then we can replace these sets by a new acceptance set. The new acceptance set $T_x$ contains all transitions from both $T_i$ and $T_j$. Fin$(T_i)$ and Fin$(T_j)$ can be removed from all disjuncts, that they belong to, and Fin$(T_x)$ is added to those disjuncts. This modification does not change the language, because Fin$(T_x)$ is equivalent to the expression $(\text{Fin}(T_i) \wedge \text{Fin}(T_j))$, if $T_x$ and $T_i \cup T_j$ are equal sets. Either expression is satisfied only if all transitions in $T_x = T_i \cup T_j$ are visited finitely often.

In other words, if the following conditions are met
\begin{itemize}
  \item $i, j \in \{1, 2, \dots, n\} , i \neq j$,
  \item $\forall d_k \in Acc' \colon \text{Fin}(T_i), \text{Fin}(T_j) \in d_k \vee \text{Fin}(T_i), \text{Fin}(T_j) \notin d_k$,
\end{itemize}
then we can define a new acceptance set $T_x = T_i \cup T_j$ a modify the $Acc'$: 
\begin{equation*}
  things
\end{equation*}

\section{Merging acceptance condition formulae of all SCCs}

\subsection{Resolving dependencies}

\subsection{Merging TODO:}


\section{Restoring equivalence with the original automaton}
\label{sec:restore_equiv}

\chapter{Implementation}

\chapter{Experimental Evaluation}

\chapter{Conclusion}

\printbibliography[heading=bibintoc]

%TODO: ???
\makeatletter\thesis@blocks@clear\makeatother
\phantomsection
\addcontentsline{toc}{chapter}{\indexname} 
\printindex

\appendix
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}
